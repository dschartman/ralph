{"id": "ralph-158i8r", "title": "Implement learning capture during wrap-up phase", "description": "Implement learning capture logic in src/soda/act.py for the wrap-up phase.\n\nPer spec:\n- WHEN task execution reveals efficiency knowledge, THEN it is captured as learning\n- WHEN task completes, THEN agent is prompted: 'What do you wish you knew before starting?'\n- WHEN learnings are captured, THEN they are actionable and project-specific\n- WHEN learnings duplicate existing memory, THEN they are noted but not duplicated\n\nThis requires:\n1. After task completion, prompt the agent with the learning question\n2. Collect agent's response as a list of learnings\n3. Deduplicate against existing memory (from context)\n4. Include non-duplicate learnings in ActOutput.learnings\n\nThe prompt should ask: 'What do you wish you knew before starting this task?'\nThe response should be parsed into actionable, project-specific items.\n\nThis is part of the 'bookended' pattern - the wrap-up phase.\n\nAdd tests for learning capture and deduplication.", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:59:07.656860Z", "updated_at": "2026-01-21T16:27:01.610921Z", "closed_at": "2026-01-21T16:27:01.610921Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "Learning capture implemented - TaskExecutionResult.learning field, collected in act()", "source": "user", "created_at": "2026-01-21T16:27:01.611257Z"}]}
{"id": "ralph-168hd7", "title": "Implement finalize logic (merge and branch cleanup)", "description": "Implement finalize logic in src/soda/act.py to merge work branch to milestone branch.\n\nPer spec:\n- WHEN all tasks are executed, THEN work branch is merged to milestone branch\n- WHEN merge conflicts occur, THEN they are resolved or documented as blocker\n- WHEN merge succeeds, THEN work branch is deleted\n- WHEN merge fails, THEN work branch is preserved for investigation\n\nFunction signature:\ndef finalize_iteration(git_client: GitClient, work_branch: str, milestone_branch: str) -> FinalizeResult\n\nFinalizeResult should contain:\n- success: bool\n- merged: bool\n- branch_deleted: bool\n- conflict_reason: Optional[str] (if merge failed)\n\nThis function:\n1. Checkout milestone_branch\n2. Attempt merge from work_branch\n3. If merge succeeds: delete work_branch, return success\n4. If merge fails: preserve work_branch, return with conflict details\n\nDepends on: GitClient.merge_branch() and GitClient.delete_branch() from ralph-16fyfw\n\nAdd tests to tests/soda/test_act.py", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:59:15.258573Z", "updated_at": "2026-01-21T16:26:35.760765Z", "closed_at": "2026-01-21T16:26:35.760765Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "finalize_iteration() implemented in act.py:582", "source": "user", "created_at": "2026-01-21T16:26:35.761121Z"}]}
{"id": "ralph-16fyfw", "title": "Add merge_branch and delete_branch methods to GitClient", "description": "GitClient in src/soda/state/git.py needs two new public methods:\n\n1. merge_branch(source_branch: str, target_branch: str) -> bool\n   - Merges source_branch into target_branch\n   - Returns True on success, False on conflict\n   - Should handle merge conflicts gracefully (return False, don't raise)\n\n2. delete_branch(branch_name: str) -> None\n   - Deletes the specified local branch\n   - Use 'git branch -d' for merged branches\n\nThese are required by ACT's finalize logic per spec:\n- 'WHEN all tasks are executed, THEN work branch is merged to milestone branch'\n- 'WHEN merge succeeds, THEN work branch is deleted'\n\nFollow existing GitClient patterns (use _run_git internally).\nAdd tests to tests/soda/state/test_git.py.", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:58:36.537020Z", "updated_at": "2026-01-21T16:26:34.790292Z", "closed_at": "2026-01-21T16:26:34.790292Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "merge_branch() and delete_branch() implemented in git.py:216,240", "source": "user", "created_at": "2026-01-21T16:26:34.791088Z"}]}
{"id": "ralph-185mr3", "title": "src/soda/act.py:19-20: Unused imports: 're' and 'subprocess' are imported at the top of the module but subprocess is only used in capture_test_baseline(). The import could be made local to avoid polluting the module namespace.. Minor - adds overhead on module import. More importantly, inconsistent with the pattern in narrow.py which does lazy imports for optional dependencies.. Move subprocess import inside capture_test_baseline() function for consistency, or keep at top level if this is intentional design.", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:19-20: Unused imports: 're' and 'subprocess' are imported at the top of the module but subprocess is only used in capture_test_baseline(). The import could be made local to avoid polluting the module namespace.. Minor - adds overhead on module import. More importantly, inconsistent with the pattern in narrow.py which does lazy imports for optional dependencies.. Move subprocess import inside capture_test_baseline() function for consistency, or keep at top level if this is intentional design.", "status": "closed", "priority": 3, "created_at": "2026-01-21T00:57:16.050641Z", "updated_at": "2026-01-21T17:07:52.292190Z", "closed_at": "2026-01-21T17:07:52.292190Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1cwnnj", "title": "src/soda/act.py:280: Hardcoded commit message format '[{task_id}] Task completed' and '[{task_id}] Uncommitted changes at task end' lack customization. Different projects may have different commit message conventions.. Minor - commit messages may not match project standards. The message format is simple but inflexible.. Consider making commit message format configurable via a template parameter or extracting to a constant at module level for easier customization.", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:280: Hardcoded commit message format '[{task_id}] Task completed' and '[{task_id}] Uncommitted changes at task end' lack customization. Different projects may have different commit message conventions.. Minor - commit messages may not match project standards. The message format is simple but inflexible.. Consider making commit message format configurable via a template parameter or extracting to a constant at module level for easier customization.", "status": "closed", "priority": 3, "created_at": "2026-01-21T00:57:16.102147Z", "updated_at": "2026-01-21T17:07:52.291360Z", "closed_at": "2026-01-21T17:07:52.291360Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1k3ykx", "title": "src/soda/act.py:277-285,311-313: commit_task_changes() and commit_or_stash_uncommitted() call git_client._run_git() directly, using the private method. This bypasses any abstraction the GitClient provides and tightly couples the ACT module to GitClient internals.. If GitClient's internal implementation changes, these functions will break. The underscore prefix convention indicates _run_git is not part of the public API.. Add public methods to GitClient like stage_all_changes(), create_commit(message), and get_head_commit_hash() to encapsulate these operations. Then use those methods from act.py.", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:277-285,311-313: commit_task_changes() and commit_or_stash_uncommitted() call git_client._run_git() directly, using the private method. This bypasses any abstraction the GitClient provides and tightly couples the ACT module to GitClient internals.. If GitClient's internal implementation changes, these functions will break. The underscore prefix convention indicates _run_git is not part of the public API.. Add public methods to GitClient like stage_all_changes(), create_commit(message), and get_head_commit_hash() to encapsulate these operations. Then use those methods from act.py.", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:57:15.947475Z", "updated_at": "2026-01-21T16:49:05.479350Z", "closed_at": "2026-01-21T16:49:05.479350Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "Added public methods to GitClient and refactored act.py to use them:\n\nNew GitClient methods:\n- stage_all_changes() - stages all changes including untracked files\n- create_commit(message) - creates commit and returns hash\n- get_head_commit_hash() - gets current HEAD commit hash\n\nUpdated _commit_all_changes() in act.py to use these instead of _run_git() directly.\n\nAdded 6 tests for the new GitClient methods. All 143 tests pass.", "source": "user", "created_at": "2026-01-21T16:49:05.480273Z"}]}
{"id": "ralph-1k6rci", "title": "Implement STUCK Handling (human participation)", "description": "# STUCK Handling Implementation\n\nHandle STUCK outcomes - pause for human input and detect resolution.\n\n## What STUCK Handling Does\n\n1. **On STUCK**\n   - Output reason to console/logs\n   - Update run status to \"stuck\" in database\n   - Store blocker details in run record\n   - Exit loop (don't block waiting for input)\n\n2. **On Resume After STUCK**\n   - SENSE detects human input via Trace\n   - Human input flows through as claim\n   - ORIENT evaluates if blocker is resolved\n   - If resolved, DECIDE returns CONTINUE\n\n## Human Input Detection (in SENSE)\nAlready implemented in sense.py:\n- Checks for pending human input in database\n- Detects spec modifications\n- Gathers recent Trace comments\n\n## STUCK Output\n```python\ndef handle_stuck(decision: Decision, run_id: int, db: SodaDB):\n    \"\"\"Handle STUCK outcome from DECIDE.\"\"\"\n    print(f\"\\n\u274c STUCK: {decision.reason}\")\n    print(\"\\nTo resolve:\")\n    print(\"1. Add comments to tasks in Trace\")\n    print(\"2. Modify the spec if requirements changed\")\n    print(\"3. Run `soda resume` to continue\")\n    \n    db.update_run(run_id, status=\"stuck\", blocker_reason=decision.reason)\n```\n\n## Resume Detection\n```python\ndef should_resume(db: SodaDB, project_id: str) -> Optional[int]:\n    \"\"\"Check if there's a stuck run to resume.\"\"\"\n    runs = db.list_runs(project_id, status=\"stuck\")\n    return runs[0].id if runs else None\n```\n\n## References\n- src/soda/sense.py human_input collection\n- src/soda/state/db.py run status updates", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:29:39.246252Z", "updated_at": "2026-01-21T16:25:38.113462Z", "closed_at": "2026-01-21T16:25:38.113462Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": [{"content": "Implementation complete - verified in codebase", "source": "user", "created_at": "2026-01-21T16:25:38.113879Z"}]}
{"id": "ralph-1l97g5", "title": "Implement SODA CLI (soda run/status/history/resume)", "description": "# SODA CLI Implementation\n\nCreate `src/soda/cli.py` - Typer-based command-line interface.\n\n## Commands Required\n\n### `soda run`\nStart a new run or continue existing one.\n```bash\nsoda run                    # Use Sodafile in current dir\nsoda run --spec path/to/spec.md\nsoda run --max-iterations 10\n```\n\n### `soda status`\nShow current run state.\n```bash\nsoda status\n# Output: Run #3, Iteration 5, Status: running, Last outcome: CONTINUE\n```\n\n### `soda history`\nList recent runs and iterations.\n```bash\nsoda history\nsoda history --runs 10      # Last 10 runs\n```\n\n### `soda resume`\nResume an interrupted/stuck run.\n```bash\nsoda resume                 # Resume most recent\nsoda resume --run-id <id>   # Resume specific run\n```\n\n## Implementation Notes\n\n1. Use Typer for CLI framework\n2. Load spec from Sodafile by default\n3. Initialize project if needed (call bootstrap)\n4. Create SodaDB instance for state\n5. Call runner.run_loop() for main execution\n\n## Entry Point\nAdd to pyproject.toml:\n```toml\n[project.scripts]\nsoda = \"soda.cli:app\"\n```\n\n## References\n- src/ralph2/cli.py for patterns\n- Typer docs: https://typer.tiangolo.com/", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:28:24.150546Z", "updated_at": "2026-01-21T16:25:38.112227Z", "closed_at": "2026-01-21T16:25:38.112227Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": [{"content": "Implementation complete - verified in codebase", "source": "user", "created_at": "2026-01-21T16:25:38.112488Z"}]}
{"id": "ralph-1o7e9j", "title": "src/soda/state/trace.py:365-395: _parse_comments() uses a simple regex that expects exactly one space before the timestamp. The regex r'^\\s+\\[([^\\]]+)\\]\\s+(\\w+):\\s+(.+)$' will fail to match multi-word sources or sources with special characters.. Comment sources like 'code-reviewer' or 'orient agent' would not be parsed correctly due to \\w+ only matching word characters.. Change the source capture group from (\\w+) to ([^:]+) to match any source name up to the colon, then strip whitespace.", "description": "Feedback from code_reviewer:\n\nsrc/soda/state/trace.py:365-395: _parse_comments() uses a simple regex that expects exactly one space before the timestamp. The regex r'^\\s+\\[([^\\]]+)\\]\\s+(\\w+):\\s+(.+)$' will fail to match multi-word sources or sources with special characters.. Comment sources like 'code-reviewer' or 'orient agent' would not be parsed correctly due to \\w+ only matching word characters.. Change the source capture group from (\\w+) to ([^:]+) to match any source name up to the colon, then strip whitespace.", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:57:16.153679Z", "updated_at": "2026-01-21T17:04:48.061076Z", "closed_at": "2026-01-21T17:04:48.061076Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1xkxqb", "title": "Implement task execution agent logic (TDD cycle)", "description": "Implement the agent invocation logic for task execution in src/soda/act.py.\n\nPer spec, when executing a task, the agent must:\n1. Read the task assignment from Trace (use TraceClient.get_task())\n2. Read relevant learnings for efficiency (from context.memory)\n3. Understand relevant code context before changing it (via Read, Glob, Grep tools)\n4. For code work: Follow TDD cycle (write failing test \u2192 implement \u2192 refactor)\n5. For non-code work (docs, config, research): Done directly\n6. For investigation tasks: Document findings in Trace comment\n\nThis requires:\n- A system prompt for the ACT agent (similar to ORIENT_SYSTEM_PROMPT)\n- Agent invocation using BookendedAgent or WalkedAgent pattern\n- Task type detection (code vs non-code vs investigation)\n- TDD guidance in the prompt\n\nThe agent should have tools: Read, Edit, Write, Bash, Glob, Grep (per spec).\n\nAdd tests that mock the agent invocation.", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:58:52.500027Z", "updated_at": "2026-01-21T16:27:00.632584Z", "closed_at": "2026-01-21T16:27:00.632584Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "EXECUTOR_SYSTEM_PROMPT, EXECUTOR_TOOLS, NarrowAgent invocation implemented in act.py", "source": "user", "created_at": "2026-01-21T16:27:00.633262Z"}]}
{"id": "ralph-1y8478", "title": "Implement async act() function with bookended agent pattern", "description": "Implement the main async act() function in src/soda/act.py following the bookended narrow pattern.\n\nThe act() function is the core orchestrator that:\n1. SETUP: Create work branch, capture test baseline, load task context\n2. WORK: For each task in iteration plan, invoke agent to execute\n3. WRAP-UP: Merge work branch to milestone branch, capture learnings\n\nFunction signature:\nasync def act(context: ActContext) -> ActOutput\n\nActContext needs:\n- git_client: GitClient\n- trace_client: TraceClient  \n- iteration_plan: IterationPlan (from ORIENT)\n- milestone_branch: str\n- iteration_number: int\n- memory: list[str] (efficiency learnings)\n\nThe function should:\n1. Call create_work_branch() to set up soda/iteration-N branch\n2. Call capture_test_baseline() to record initial test state\n3. For each task in iteration_plan.tasks:\n   - Invoke agent to execute task (use BookendedAgent or WalkedAgent)\n   - Handle completion vs blocked status\n4. Call finalize logic (merge, delete branch)\n5. Return ActOutput with all results\n\nReference: src/soda/orient.py for similar async function pattern\nReference: src/ralph2/agents/executor.py for executor patterns\n\nAdd tests to tests/soda/test_act.py", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:58:37.505049Z", "updated_at": "2026-01-21T16:26:38.687768Z", "closed_at": "2026-01-21T16:26:38.687768Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "async def act() implemented in act.py:807", "source": "user", "created_at": "2026-01-21T16:26:38.688075Z"}]}
{"id": "ralph-3lda19", "title": "Implement Milestone Phase (branch and work item setup)", "description": "# Milestone Phase Implementation\n\nSetup milestone branch and root work item for each run.\n\n## What Milestone Phase Does\n\n1. **Create Milestone Branch**\n   - Branch name: `soda/milestone-<short-hash>` or from spec title\n   - Create from main branch\n   - Handle name conflicts with numbered suffix\n\n2. **Create Root Work Item**\n   - Extract title from spec (first H1 heading)\n   - Create task in Trace: `trc create \"<title>\" --description \"<spec summary>\"`\n   - Store root_work_item_id in run record\n\n3. **Handle Resume**\n   - If run exists with milestone branch, reuse it\n   - If run exists with root work item, reuse it\n   - Don't recreate on resume\n\n## Function Signature\n```python\nasync def setup_milestone(\n    project_id: str,\n    spec_content: str,\n    git_client: GitClient,\n    trace_client: TraceClient,\n    db: SodaDB,\n    run_id: Optional[int] = None,  # For resume\n) -> MilestoneContext:\n    \"\"\"Setup milestone branch and root work item.\n    \n    Returns:\n        MilestoneContext with branch name and work item ID\n    \"\"\"\n```\n\n## MilestoneContext Structure\n```python\nclass MilestoneContext(BaseModel):\n    milestone_branch: str\n    root_work_item_id: str\n    is_resumed: bool\n```\n\n## Spec Title Extraction\n```python\ndef extract_spec_title(spec_content: str) -> str:\n    # Find first H1: # Title\n    match = re.search(r'^#\\s+(.+)$', spec_content, re.MULTILINE)\n    return match.group(1) if match else \"SODA Work Item\"\n```\n\n## References\n- src/soda/state/git.py create_branch()\n- src/soda/state/trace.py create_task()", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:29:27.414157Z", "updated_at": "2026-01-21T16:25:38.110885Z", "closed_at": "2026-01-21T16:25:38.110885Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": [{"content": "Implementation complete - verified in codebase", "source": "user", "created_at": "2026-01-21T16:25:38.111194Z"}]}
{"id": "ralph-74ze8c", "title": "Write integration tests for M6 Full Loop", "description": "# M6 Integration Tests\n\nWrite integration tests for the full SODA loop.\n\n## Test Scenarios\n\n### 1. Happy Path End-to-End\n- Fresh project with simple spec\n- Loop runs SENSE \u2192 ORIENT \u2192 DECIDE \u2192 ACT\n- Reaches DONE in \u22643 iterations\n- Summary is written\n\n### 2. STUCK and Resume\n- Spec with impossible requirement\n- Loop reaches STUCK\n- Add human input (modify spec)\n- Resume and reach DONE\n\n### 3. Max Iterations\n- Spec that can't be satisfied\n- Loop runs until max iterations\n- Properly halts and records state\n\n### 4. Kickstart (New Project)\n- Empty directory with just Sodafile\n- First iteration scaffolds project\n- Subsequent iterations do real work\n\n### 5. Bootstrap Idempotency\n- Run bootstrap twice\n- Second run reuses existing project ID\n- No duplicate work items created\n\n## Test Infrastructure\n\n### Fixtures\n```python\n@pytest.fixture\ndef temp_project(tmp_path):\n    \"\"\"Create a temporary project directory with git init.\"\"\"\n    project_dir = tmp_path / \"test_project\"\n    project_dir.mkdir()\n    subprocess.run([\"git\", \"init\"], cwd=project_dir)\n    subprocess.run([\"git\", \"commit\", \"--allow-empty\", \"-m\", \"init\"], cwd=project_dir)\n    return project_dir\n\n@pytest.fixture\ndef simple_spec():\n    return '''\n# Test Feature\n\n## Acceptance Criteria\n- [ ] WHEN test runs THEN it passes\n'''\n```\n\n### Mocking External Services\n- Mock Claude API calls (use NarrowAgent mock)\n- Use real git (in temp directory)\n- Use real Trace (in temp directory)\n\n## Test File\nCreate `tests/soda/test_full_loop.py`\n\n## Definition of Done\n- All scenarios have passing tests\n- Tests run in <30 seconds total\n- No external API calls (all mocked)", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:30:31.959302Z", "updated_at": "2026-01-21T16:59:05.090797Z", "closed_at": "2026-01-21T16:59:05.090797Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": []}
{"id": "ralph-7soyh6", "title": "Implement Bootstrap Phase (project initialization)", "description": "# Bootstrap Phase Implementation\n\nAdd bootstrap logic to runner - handles first-time project setup.\n\n## What Bootstrap Does\n\n1. **Project Initialization**\n   - Create .soda-id if not exists (UUID)\n   - Create ~/.soda/projects/<project-id>/ directory\n   - Initialize SodaDB\n\n2. **Git Initialization**\n   - If repo has no commits, create initial empty commit\n   - Ensure git is in clean state\n\n3. **Validation**\n   - Verify spec file exists and is readable\n   - Verify git repo exists\n\n## Function Signature\n```python\nasync def bootstrap(\n    working_dir: str,\n    spec_path: str,\n) -> BootstrapResult:\n    \"\"\"Initialize project for SODA run.\n    \n    Returns:\n        BootstrapResult with project_id, spec_content, is_new_project\n    \"\"\"\n```\n\n## BootstrapResult Structure\n```python\nclass BootstrapResult(BaseModel):\n    project_id: str\n    spec_content: str\n    is_new_project: bool  # True if .soda-id was just created\n    is_kickstart: bool    # True if project has no code structure\n```\n\n## Kickstart Detection\nCheck if project needs scaffolding:\n- No pyproject.toml AND no package.json AND no Cargo.toml\n- No src/ directory\n- Set is_kickstart=True to signal first iteration should scaffold\n\n## References\n- src/soda/project.py has init_project() already\n- src/ralph2/runner.py bootstrap patterns", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:29:13.171475Z", "updated_at": "2026-01-21T16:25:38.109574Z", "closed_at": "2026-01-21T16:25:38.109574Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": [{"content": "Implementation complete - verified in codebase", "source": "user", "created_at": "2026-01-21T16:25:38.110276Z"}]}
{"id": "ralph-843yhu", "title": "src/soda/act.py:364-370: verify_task() treats missing pytest (FileNotFoundError) as verification success (passed=True). When pytest is not installed, the function silently passes verification instead of indicating tests could not be run.. If a project expects tests to run but pytest is not installed, verification will incorrectly report success. This could allow broken code to proceed through ACT as 'verified' when it was never actually tested. Different from ralph-dtg2la which only addresses missing logging, not the semantic correctness of the return value.. Return a VerifyResult with passed=False and a descriptive new_failure like '<pytest not available - verification skipped>' to distinguish from actual test success. Or add a 'skipped' field to VerifyResult to explicitly indicate verification was not performed.", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:364-370: verify_task() treats missing pytest (FileNotFoundError) as verification success (passed=True). When pytest is not installed, the function silently passes verification instead of indicating tests could not be run.. If a project expects tests to run but pytest is not installed, verification will incorrectly report success. This could allow broken code to proceed through ACT as 'verified' when it was never actually tested. Different from ralph-dtg2la which only addresses missing logging, not the semantic correctness of the return value.. Return a VerifyResult with passed=False and a descriptive new_failure like '<pytest not available - verification skipped>' to distinguish from actual test success. Or add a 'skipped' field to VerifyResult to explicitly indicate verification was not performed.", "status": "closed", "priority": 2, "created_at": "2026-01-21T01:54:35.659315Z", "updated_at": "2026-01-21T16:40:24.142637Z", "closed_at": "2026-01-21T16:40:24.142637Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "Fixed verify_task() to handle missing pytest correctly based on baseline expectations:\n\n- If baseline.has_tests=True and pytest not found \u2192 regression (passed=False, regressions=True)\n- If baseline.has_tests=False and pytest not found \u2192 consistent (passed=True, regressions=False)\n\nAdded 2 tests:\n- test_verify_task_pytest_not_found_with_expected_tests\n- test_verify_task_pytest_not_found_no_expected_tests\n\nAll 114 tests pass.", "source": "user", "created_at": "2026-01-21T16:40:24.143432Z"}]}
{"id": "ralph-8gga29", "title": "Write tests for M5 ACT function", "description": "# M5 ACT Tests\n\nWrite tests for the newly implemented act() function and related components.\n\n## Components to Test\n\n### ActContext\n- Test creation with all fields\n- Test JSON serialization\n- Test optional fields\n\n### TaskExecutionResult\n- Test completed=True case\n- Test blocked=True with blocker_reason\n- Test subtasks_needed list\n- Test learning capture\n\n### EXECUTOR_SYSTEM_PROMPT\n- Verify prompt covers TDD cycle\n- Verify prompt covers non-code work\n- Verify prompt covers investigation tasks\n- Verify output schema is documented\n\n### act() Function\n- Test with mock NarrowAgent\n- Test work branch creation\n- Test baseline capture\n- Test task iteration\n- Test blocked task handling\n- Test verification failure handling\n- Test commit creation\n- Test finalize merge\n\n## Test File\nCreate `tests/soda/test_act.py`\n\n## Mocking Strategy\n```python\n@pytest.fixture\ndef mock_narrow_agent(mocker):\n    mock = mocker.patch(\"soda.act.NarrowAgent\")\n    mock.return_value.invoke = AsyncMock(return_value=TaskExecutionResult(\n        completed=True,\n        progress_notes=\"Did the thing\",\n    ))\n    return mock\n\n@pytest.fixture\ndef mock_git_client(mocker):\n    # Mock GitClient methods used by act()\n    ...\n\n@pytest.fixture\ndef mock_trace_client(mocker):\n    # Mock TraceClient methods used by act()\n    ...\n```\n\n## Key Test Cases\n1. Happy path: all tasks complete successfully\n2. Blocked task: agent returns blocked=True\n3. Verification failure: new test failures detected\n4. Finalize failure: merge conflict\n5. Agent error: invoke() raises exception", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:30:18.098530Z", "updated_at": "2026-01-21T16:34:05.143566Z", "closed_at": "2026-01-21T16:34:05.143566Z", "dependencies": [], "comments": [{"content": "Added comprehensive tests for M5 ACT function:\n- ActContext model tests (8 tests)\n- TaskExecutionResult model tests (7 tests)\n- EXECUTOR_SYSTEM_PROMPT tests (6 tests)\n- act() function tests with mocking (13 tests)\n- _build_executor_prompt tests (6 tests)\n\nTotal: 40 new tests added. All 112 tests in test_act.py pass.", "source": "user", "created_at": "2026-01-21T16:34:05.144275Z"}]}
{"id": "ralph-dce2x7", "title": "Implement task verification logic (compare tests to baseline)", "description": "Implement verification logic in src/soda/act.py to compare test results against baseline.\n\nPer spec:\n- WHEN implementation is complete, THEN tests are run\n- WHEN tests pass, THEN task is marked completed\n- WHEN tests fail, THEN failures are compared to baseline\n- WHEN new failures exist (not in baseline), THEN agent must fix or document as blocker\n- WHEN agent cannot complete task, THEN task is marked blocked with reason\n\nImplement a function like:\ndef verify_task(git_client: GitClient, baseline: TestBaseline) -> VerifyResult\n\nVerifyResult should contain:\n- passed: bool\n- new_failures: list[str] (test names that failed but weren't in baseline)\n- regressions: bool (True if new_failures > 0)\n\nThis function:\n1. Runs pytest (reuse capture_test_baseline's subprocess logic)\n2. Compares results to baseline.failed_tests\n3. Returns verification result\n\nAdd tests to tests/soda/test_act.py", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:58:53.377380Z", "updated_at": "2026-01-21T16:26:36.722925Z", "closed_at": "2026-01-21T16:26:36.722925Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "verify_task() implemented in act.py:309", "source": "user", "created_at": "2026-01-21T16:26:36.723305Z"}]}
{"id": "ralph-dtg2la", "title": "src/soda/act.py:308-383: verify_task() function has no error logging for exception cases. When FileNotFoundError or subprocess.TimeoutExpired occurs, errors are silently converted to VerifyResult without any diagnostic logging.. Makes debugging verification failures difficult in production. Operators cannot distinguish between missing pytest and actual test failures without logging.. Add debug-level logging before each exception handling block: `logger.debug(f'Verification failed: {e}')`. Import logger at module level.", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:308-383: verify_task() function has no error logging for exception cases. When FileNotFoundError or subprocess.TimeoutExpired occurs, errors are silently converted to VerifyResult without any diagnostic logging.. Makes debugging verification failures difficult in production. Operators cannot distinguish between missing pytest and actual test failures without logging.. Add debug-level logging before each exception handling block: `logger.debug(f'Verification failed: {e}')`. Import logger at module level.", "status": "closed", "priority": 2, "created_at": "2026-01-21T01:36:50.661466Z", "updated_at": "2026-01-21T17:04:48.060031Z", "closed_at": "2026-01-21T17:04:48.060031Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-ekkkx4", "title": "Implement SODA Runner (iteration loop orchestrator)", "description": "# SODA Runner Implementation\n\nCreate `src/soda/runner.py` - the main iteration loop that orchestrates SENSE \u2192 ORIENT \u2192 DECIDE \u2192 ACT.\n\n## What It Does\n1. Runs the iteration loop until DONE or STUCK\n2. Calls each phase in sequence\n3. Handles routing based on DECIDE output\n4. Tracks iteration count and enforces limits\n\n## Key Functions Needed\n\n### `async def run_iteration(ctx: RunContext) -> IterationResult`\nSingle iteration: SENSE \u2192 ORIENT \u2192 DECIDE \u2192 (ACT if CONTINUE)\n\n### `async def run_loop(ctx: RunContext) -> RunResult`\nFull loop that calls run_iteration until termination condition.\n\n## Data Structures Needed\n\n### RunContext\n- project_id: str\n- spec_content: str\n- milestone_branch: str\n- root_work_item_id: str\n- max_iterations: int (default 20)\n- working_directory: Optional[str]\n\n### IterationResult\n- iteration_num: int\n- outcome: DONE | STUCK | CONTINUE\n- orient_output: OrientOutput\n- act_output: Optional[ActOutput]\n\n### RunResult\n- status: done | stuck | max_iterations\n- iterations_completed: int\n- final_outcome: str\n- summary: str\n\n## Routing Logic (from DECIDE)\n```python\nmatch decision.outcome:\n    case DONE:\n        return RunResult(status=\"done\", ...)\n    case STUCK:\n        return RunResult(status=\"stuck\", reason=decision.reason, ...)\n    case CONTINUE:\n        act_output = await act(act_context, git_client, trace_client)\n        # Loop back to SENSE\n```\n\n## References\n- src/ralph2/runner.py for patterns\n- src/soda/sense.py, orient.py, decide.py, act.py for phase interfaces", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:28:12.645263Z", "updated_at": "2026-01-21T16:25:38.111549Z", "closed_at": "2026-01-21T16:25:38.111549Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": [{"content": "Implementation complete - verified in codebase", "source": "user", "created_at": "2026-01-21T16:25:38.111898Z"}]}
{"id": "ralph-fvfllr", "title": "Implement Trace integration for task updates", "description": "Implement Trace integration in src/soda/act.py for posting comments, closing tasks, and creating subtasks.\n\nPer spec:\n- WHEN work is done on a task, THEN a progress comment is posted to Trace\n- WHEN a task is completed, THEN it is closed in Trace with completion comment\n- WHEN a blocker is encountered, THEN it is documented in Trace with details\n- WHEN subtasks are discovered during work, THEN they are created in Trace under parent\n\nFunctions needed:\n1. post_progress_comment(trace_client, task_id, comment) -> TaskComment\n2. close_task(trace_client, task_id, completion_message) -> None\n3. mark_task_blocked(trace_client, task_id, blocker_reason) -> None\n4. create_subtask(trace_client, parent_id, title, description) -> str (new task ID)\n\nThese should use TraceClient methods (may need to add some to TraceClient if missing):\n- trc comment <id> <text>\n- trc close <id>\n- trc create with --parent\n\nAdd tests that mock TraceClient._run_command()", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:59:06.369603Z", "updated_at": "2026-01-21T16:26:37.713802Z", "closed_at": "2026-01-21T16:26:37.713802Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "post_progress_comment, close_task_in_trace, mark_task_blocked implemented in act.py", "source": "user", "created_at": "2026-01-21T16:26:37.714189Z"}]}
{"id": "ralph-jgqpme", "title": "src/soda/act.py:255-286: commit_task_changes() has logic duplication with commit_or_stash_uncommitted(). Both functions do: check for changes \u2192 stage all \u2192 commit \u2192 get hash. The only difference is the commit message.. Maintenance burden - bug fixes or changes to commit logic need to be applied in two places. Also, the docstring for commit_or_stash_uncommitted says it can 'commit or stash' but only commits (no stash logic).. Extract shared commit logic into a private helper like _commit_all_changes(git_client, message) -> Optional[str]. Update commit_or_stash_uncommitted docstring or implement actual stash logic if needed.", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:255-286: commit_task_changes() has logic duplication with commit_or_stash_uncommitted(). Both functions do: check for changes \u2192 stage all \u2192 commit \u2192 get hash. The only difference is the commit message.. Maintenance burden - bug fixes or changes to commit logic need to be applied in two places. Also, the docstring for commit_or_stash_uncommitted says it can 'commit or stash' but only commits (no stash logic).. Extract shared commit logic into a private helper like _commit_all_changes(git_client, message) -> Optional[str]. Update commit_or_stash_uncommitted docstring or implement actual stash logic if needed.", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:57:15.998948Z", "updated_at": "2026-01-21T16:43:27.905879Z", "closed_at": "2026-01-21T16:43:27.905879Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "Refactored commit functions to eliminate duplication:\n\n1. Created _commit_all_changes(git_client, message) helper with shared logic\n2. Simplified commit_task_changes() to use helper (was 15 lines, now 3)\n3. Renamed commit_or_stash_uncommitted \u2192 commit_uncommitted_changes (accurate name)\n4. Fixed misleading docstring (removed 'stashed' from return type)\n5. Added backward compat alias: commit_or_stash_uncommitted = commit_uncommitted_changes\n\nAll 114 tests pass.", "source": "user", "created_at": "2026-01-21T16:43:27.906695Z"}]}
{"id": "ralph-l2k4rh", "title": "Milestone 6: Full Loop Implementation", "description": "# M6: Full Loop Implementation\n\nThe full SODA loop integrates all components into an end-to-end autonomous system.\n\n## Prerequisites (Complete)\n- M1 Agent Infrastructure \u2705\n- M2 State Layer \u2705  \n- M3 SENSE + DECIDE \u2705\n- M4 ORIENT \u2705\n- M5 ACT \u2705\n\n## Spec Reference\nSee `Soda-M6-Full-Loop.md` for full acceptance criteria.\n\n## Key Components to Build\n1. Runner (src/soda/runner.py) - Main iteration loop\n2. CLI (src/soda/cli.py) - Command-line interface\n3. Bootstrap phase - Project initialization\n4. Milestone phase - Branch/work item setup\n5. STUCK handling - Human participation\n6. Run completion - Summaries and status\n\n## Architecture\n```\nsoda run \u2192 Bootstrap \u2192 Milestone Setup \u2192 Iteration Loop\n                                              \u2193\n                         SENSE \u2192 ORIENT \u2192 DECIDE\n                           \u2191                  \u2193\n                           \u2190\u2500\u2500 ACT \u2190\u2500\u2500 CONTINUE\n                                       \u2193\n                                   DONE/STUCK \u2192 Complete\n```\n\n## Assets\n- docs/soda-loop.md\n- src/ralph2/runner.py (reference)\n- src/ralph2/cli.py (reference)", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:28:00.492942Z", "updated_at": "2026-01-21T16:59:13.783299Z", "closed_at": "2026-01-21T16:59:13.783299Z", "dependencies": [], "comments": []}
{"id": "ralph-msvbt4", "title": "Implement Run Completion (summaries and status)", "description": "# Run Completion Implementation\n\nHandle run completion - write summaries and update status.\n\n## What Run Completion Does\n\n1. **Update Database**\n   - Set run status to \"done\" or \"stuck\"\n   - Record final iteration count\n   - Store completion timestamp\n\n2. **Write Summary**\n   - Create summary markdown file\n   - Store in ~/.soda/projects/<project-id>/summaries/\n   - Filename: run-<run-id>-<timestamp>.md\n\n3. **Console Output**\n   - Print completion message\n   - Show iterations completed\n   - Show next steps (e.g., \"Create PR from milestone branch\")\n\n## Summary Format\n```markdown\n# SODA Run Summary\n\n**Run ID:** 42\n**Status:** DONE\n**Iterations:** 5\n**Completed:** 2024-01-21T10:30:00Z\n\n## Spec\n<spec title>\n\n## Tasks Completed\n- ralph-abc123: Implement feature X\n- ralph-def456: Fix bug Y\n\n## Tasks Blocked\n- ralph-ghi789: Blocked by external API (reason)\n\n## Learnings Captured\n- Tests are in tests/soda/\n- Use `uv run pytest` to run tests\n\n## Next Steps\n1. Review changes on branch `soda/milestone-xyz`\n2. Create PR: `gh pr create --base main --head soda/milestone-xyz`\n```\n\n## Function Signature\n```python\ndef complete_run(\n    run_id: int,\n    status: Literal[\"done\", \"stuck\"],\n    iterations: int,\n    tasks_completed: list[str],\n    tasks_blocked: list[BlockedTask],\n    learnings: list[str],\n    db: SodaDB,\n    project_dir: Path,\n) -> Path:\n    \"\"\"Complete a run and write summary.\n    \n    Returns:\n        Path to the summary file\n    \"\"\"\n```\n\n## References\n- src/ralph2/runner.py completion patterns\n- src/soda/state/db.py for run updates", "status": "closed", "priority": 2, "created_at": "2026-01-21T15:30:04.056039Z", "updated_at": "2026-01-21T16:25:38.112796Z", "closed_at": "2026-01-21T16:25:38.112796Z", "dependencies": [{"depends_on_id": "ralph-l2k4rh", "type": "parent"}], "comments": [{"content": "Implementation complete - verified in codebase", "source": "user", "created_at": "2026-01-21T16:25:38.113076Z"}]}
{"id": "ralph-t44ka1", "title": "src/soda/act.py:181-247: capture_test_baseline() uses subprocess.run() directly without going through GitClient or a testable abstraction. The function calls pytest via subprocess, making it impossible to mock for testing without patching the subprocess module.. Tests for capture_test_baseline() require actually running pytest in tmp_path rather than using mocks, which makes tests slower and harder to maintain. Also, the function is tightly coupled to pytest's output format which could change.. Extract the subprocess call into a mockable method like _run_pytest() or accept a test runner callable as a parameter. This follows the same pattern used in GitClient._run_git() and TraceClient._run_command().", "description": "Feedback from code_reviewer:\n\nsrc/soda/act.py:181-247: capture_test_baseline() uses subprocess.run() directly without going through GitClient or a testable abstraction. The function calls pytest via subprocess, making it impossible to mock for testing without patching the subprocess module.. Tests for capture_test_baseline() require actually running pytest in tmp_path rather than using mocks, which makes tests slower and harder to maintain. Also, the function is tightly coupled to pytest's output format which could change.. Extract the subprocess call into a mockable method like _run_pytest() or accept a test runner callable as a parameter. This follows the same pattern used in GitClient._run_git() and TraceClient._run_command().", "status": "closed", "priority": 2, "created_at": "2026-01-21T00:57:15.895752Z", "updated_at": "2026-01-21T16:26:39.642107Z", "closed_at": "2026-01-21T16:26:39.642107Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "_run_pytest() extracted in act.py:197", "source": "user", "created_at": "2026-01-21T16:26:39.642436Z"}]}
