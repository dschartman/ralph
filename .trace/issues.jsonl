{"id": "ralph-10gpvy", "title": "Implement output capture module", "description": "Create src/soda/outputs/capture.py for JSONL output capture.\n\n## Class: OutputCapture\n- save(agent_type, prompt_summary, raw_output, metadata) -> Path\n- Uses outputs/ directory\n- JSONL format (one JSON object per line)\n- Date-based filenames: outputs/YYYY-MM-DD.jsonl\n- Non-blocking (capture failures don't affect agent results)\n\n## Output format:\n```json\n{\"timestamp\": \"ISO8601\", \"agent_type\": \"narrow\", \"prompt_summary\": \"...\", \"output\": {...}}\n```\n\n## Tests:\n- tests/soda/test_output_capture.py\n- Test file creation\n- Test JSONL format\n- Test non-blocking behavior\n\n## Depends on: Scaffolding complete (ralph-fs2dsc)", "status": "closed", "priority": 1, "created_at": "2026-01-20T18:29:35.436121Z", "updated_at": "2026-01-20T18:35:58.842595Z", "closed_at": "2026-01-20T18:35:58.842595Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": []}
{"id": "ralph-126r24", "title": "Implement Soda data models", "description": "Create data models in src/soda/state/models.py following Ralph2 patterns:\n\n## Models to Create\n1. Run - id, spec_content, status, timestamp fields\n2. Iteration - linked to run, number, intent, outcome, timestamps\n3. AgentOutput - linked to iteration, agent_type, output_path, summary\n4. HumanInput - linked to run, input_type, content, created_at, consumed_at\n\n## Requirements\n- Use dataclasses\n- Include to_dict() method on each model\n- Status values: running, completed, stuck, paused, aborted\n- Outcome values: continue, done, stuck\n\n## Tests\n- Create tests/soda/state/test_models.py\n- Test to_dict() serialization for each model\n- Test datetime handling\n\nReference: src/ralph2/state/models.py", "status": "closed", "priority": 2, "created_at": "2026-01-20T20:16:06.719996Z", "updated_at": "2026-01-20T20:30:02.469534Z", "closed_at": "2026-01-20T20:30:02.469534Z", "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-127ogi", "title": "Project scaffolding: soda package structure", "description": "Create the foundational project structure for the soda package.\n\n## What to create\n1. src/soda/ directory with __init__.py\n2. src/soda/agents/ directory with __init__.py  \n3. src/soda/outputs/ directory with __init__.py\n4. Update pyproject.toml to include soda package\n5. Create basic type definitions (src/soda/types.py) - placeholder Pydantic models\n\n## Technical constraints\n- Use Python 3.11+ features\n- Use Pydantic v2 for model definitions\n- Structure should mirror src/ralph2/ patterns where appropriate\n\n## Verification\n- `import soda` should work\n- `import soda.agents` should work\n- pyproject.toml has soda in packages", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:47:48.829891Z", "updated_at": "2026-01-20T17:50:35.463205Z", "closed_at": "2026-01-20T17:50:35.463205Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on project scaffolding for soda package", "source": "executor", "created_at": "2026-01-20T17:48:47.821949Z"}, {"content": "Completed project scaffolding:\n- Created src/soda/ directory structure with __init__.py\n- Created src/soda/agents/__init__.py for agent modules\n- Created src/soda/outputs/__init__.py for output capture\n- Created src/soda/types.py with Pydantic models (AgentConfig, StructuredOutput, AgentInvocation, Message, Conversation, AgentError, ValidationError)\n- Updated pyproject.toml to include soda script entry point\n- Created tests/soda/test_scaffolding.py with 16 tests - all passing\n\nVerified:\n- import soda works\n- import soda.agents works\n- import soda.outputs works\n- All type definitions work with Pydantic v2", "source": "executor", "created_at": "2026-01-20T17:50:22.040597Z"}]}
{"id": "ralph-13h2rf", "title": "Implement Soda memory management", "description": "Implement memory management operations (may be partially in project.py):\n\n## Spec Criteria\n- WHEN reading memory for a project, THEN memory.md content returned (empty string if not exists)\n- WHEN writing memory, THEN content saved to ~/.soda/projects/<project-id>/memory.md\n- WHEN memory updated, THEN previous content preserved unless explicitly overwritten\n- WHEN memory exceeds 50KB, THEN a warning is logged\n\n## Functions\n- read_memory(project_id) -> str\n- write_memory(project_id, content) -> None\n- check_memory_size(project_id) -> None (log warning if > 50KB)\n\n## Tests\n- Create tests for memory operations\n- Test empty memory returns empty string\n- Test write preserves until overwrite\n- Test 50KB warning logged\n\nReference: src/ralph2/project.py (read_memory, write_memory functions)", "status": "open", "priority": 2, "created_at": "2026-01-20T20:16:20.473989Z", "updated_at": "2026-01-20T20:16:20.473989Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-148trj", "title": "Implement error handling with retry logic", "description": "Create error handling infrastructure that distinguishes transient vs fatal errors.\n\n## Requirements\n- Transient errors: rate limit, timeout, connection error, 5xx \u2192 retry with exponential backoff (max 3 attempts)\n- Fatal errors: invalid API key, 401, 403, permission denied \u2192 halt immediately\n- Unknown errors \u2192 treat as transient (retry)\n- After max retries exhausted \u2192 surface error with full context\n\n## Interface\n```python\nclass RetryHandler:\n    def execute_with_retry(self, func: Callable, max_attempts: int = 3) -> T:\n        \"\"\"Execute function with exponential backoff retry on transient errors.\"\"\"\n        \ndef is_transient_error(error: Exception) -> bool:\n    \"\"\"Classify error as transient (retry) or fatal (halt).\"\"\"\n```\n\n## Verification\n- Transient errors trigger retries up to max_attempts\n- Fatal errors halt immediately without retry\n- Backoff increases exponentially between retries\n- Error context preserved in final exception", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:14.084944Z", "updated_at": "2026-01-20T17:56:46.997978Z", "closed_at": "2026-01-20T17:56:46.997978Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on error handling with retry logic implementation", "source": "executor", "created_at": "2026-01-20T17:54:42.504716Z"}, {"content": "Completed implementation of error handling with retry logic.\n\nCreated src/soda/errors.py with:\n- TransientError, FatalError, MaxRetriesExhaustedError exception classes\n- is_transient_error() function for error classification\n- RetryHandler class with execute_with_retry() method implementing exponential backoff\n\nTest coverage (29 tests):\n- TestIsTransientError: 10 tests verifying error classification\n- TestTransientError/FatalError/MaxRetriesExhaustedError: 6 tests for exception classes\n- TestRetryHandler: 13 tests verifying retry behavior, backoff, and error context\n\nAll tests passing (78/78 in soda test suite).", "source": "executor", "created_at": "2026-01-20T17:56:31.871785Z"}]}
{"id": "ralph-1528jp", "title": "src/ralph2/agents/verifier.py:198-239: Assessment string building logic is duplicated. Lines 198-211 build assessment for Trace comment, and lines 228-239 build nearly identical assessment for runner consumption. Both loops iterate over criteria_status with similar formatting.. Code duplication increases maintenance burden. If the assessment format needs to change, two places need to be updated which is error-prone. The current code already has a slight difference in format (line 203 uses `[{symbol}]` while line 233 uses `{symbol}`) which may or may not be intentional.. Extract a `_build_assessment_string(result: VerifierResult, format_style: str = 'standard') -> str` helper function that can be parameterized for the minor formatting differences, or use the same format for both use cases.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/agents/verifier.py:198-239: Assessment string building logic is duplicated. Lines 198-211 build assessment for Trace comment, and lines 228-239 build nearly identical assessment for runner consumption. Both loops iterate over criteria_status with similar formatting.. Code duplication increases maintenance burden. If the assessment format needs to change, two places need to be updated which is error-prone. The current code already has a slight difference in format (line 203 uses `[{symbol}]` while line 233 uses `{symbol}`) which may or may not be intentional.. Extract a `_build_assessment_string(result: VerifierResult, format_style: str = 'standard') -> str` helper function that can be parameterized for the minor formatting differences, or use the same format for both use cases.", "status": "open", "priority": 2, "created_at": "2026-01-20T18:00:26.165700Z", "updated_at": "2026-01-20T18:00:26.165700Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-1566lk", "title": "src/ralph2/runner.py:552-597: Methods _cleanup_worktrees() and _cleanup_branches() have bare exception handlers that silently swallow all errors. The outer _cleanup_abandoned_branches() also catches generic Exception.. Silent exception swallowing makes debugging difficult. If cleanup fails unexpectedly, the root cause may never be discovered.. Log specific exception types and messages, even if continuing execution. Consider at minimum logging the exception type and message before continuing.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/runner.py:552-597: Methods _cleanup_worktrees() and _cleanup_branches() have bare exception handlers that silently swallow all errors. The outer _cleanup_abandoned_branches() also catches generic Exception.. Silent exception swallowing makes debugging difficult. If cleanup fails unexpectedly, the root cause may never be discovered.. Log specific exception types and messages, even if continuing execution. Consider at minimum logging the exception type and message before continuing.", "status": "open", "priority": 2, "created_at": "2026-01-20T18:08:50.367988Z", "updated_at": "2026-01-20T18:08:50.367988Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
{"id": "ralph-15a34l", "title": "src/soda/agents/bookended.py:156-180: BookendedAgent._invoke_agent() raises NotImplementedError, same as WalkedAgent, meaning the bookended pattern also cannot be used in production with the Claude SDK.. BookendedAgent cannot be used in production - only works with mocks in tests. This is a consistency issue since NarrowAgent has real SDK integration but WalkedAgent and BookendedAgent do not.. Implement actual Claude SDK integration similar to NarrowAgent._call_agent(). Should use the walked conversation pattern with message history passed to the SDK. Note: ralph-qmuqrr tracks this for WalkedAgent but not for BookendedAgent.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/bookended.py:156-180: BookendedAgent._invoke_agent() raises NotImplementedError, same as WalkedAgent, meaning the bookended pattern also cannot be used in production with the Claude SDK.. BookendedAgent cannot be used in production - only works with mocks in tests. This is a consistency issue since NarrowAgent has real SDK integration but WalkedAgent and BookendedAgent do not.. Implement actual Claude SDK integration similar to NarrowAgent._call_agent(). Should use the walked conversation pattern with message history passed to the SDK. Note: ralph-qmuqrr tracks this for WalkedAgent but not for BookendedAgent.", "status": "open", "priority": 2, "created_at": "2026-01-20T20:01:56.743500Z", "updated_at": "2026-01-20T20:01:56.743500Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-15c5px", "title": "src/soda/agents/walked.py:86-119: WalkedAgent.send() does not use the _retry_handler for _invoke_agent calls, same as BookendedAgent.. Transient errors during walked agent invocations will not be automatically retried. The agent has a _retry_handler attribute but doesn't use it, causing inconsistent error handling between agent patterns.. Wrap _invoke_agent() call with self._retry_handler.execute_with_retry() similar to NarrowAgent, or document why retry logic is intentionally omitted for conversational patterns.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/walked.py:86-119: WalkedAgent.send() does not use the _retry_handler for _invoke_agent calls, same as BookendedAgent.. Transient errors during walked agent invocations will not be automatically retried. The agent has a _retry_handler attribute but doesn't use it, causing inconsistent error handling between agent patterns.. Wrap _invoke_agent() call with self._retry_handler.execute_with_retry() similar to NarrowAgent, or document why retry logic is intentionally omitted for conversational patterns.", "status": "open", "priority": 3, "created_at": "2026-01-20T20:01:56.906598Z", "updated_at": "2026-01-20T20:01:56.906598Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
{"id": "ralph-160dyp", "title": "src/soda/validation.py:129: Type annotation uses lowercase 'any' instead of 'Any' from typing module. Line: `def _get_nested_value(self, data: dict, loc: tuple) -> any:`. This is technically invalid Python type annotation. While it works at runtime (Python treats 'any' as a string annotation), it violates typing conventions and static type checkers will flag it.. Import `Any` from typing and change the return type annotation to `-> Any:`", "description": "Feedback from code_reviewer:\n\nsrc/soda/validation.py:129: Type annotation uses lowercase 'any' instead of 'Any' from typing module. Line: `def _get_nested_value(self, data: dict, loc: tuple) -> any:`. This is technically invalid Python type annotation. While it works at runtime (Python treats 'any' as a string annotation), it violates typing conventions and static type checkers will flag it.. Import `Any` from typing and change the return type annotation to `-> Any:`", "status": "open", "priority": 2, "created_at": "2026-01-20T18:41:36.551886Z", "updated_at": "2026-01-20T18:41:36.551886Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1w1g1o", "type": "parent"}], "comments": []}
{"id": "ralph-1620s1", "title": "Implement bookended agent pattern", "description": "Create the bookended agent pattern - setup prompts, main work, wrap-up prompts.\n\n## Requirements\n- Execute setup prompts before main work prompt\n- Execute main work prompt\n- Execute wrap-up prompts in same context after main work\n- Capture full conversation (setup + work + wrap-up) to JSONL\n\n## Interface\n```python\nclass BookendedAgent:\n    def invoke(\n        self,\n        setup_prompts: List[str],\n        work_prompt: str,\n        wrapup_prompts: List[str],\n        output_schema: Optional[Type[BaseModel]] = None\n    ) -> BookendedResult:\n        \"\"\"Execute bookended pattern, return all results.\"\"\"\n```\n\n## Dependencies\n- Output capture module  \n- Walked agent (for context persistence)\n- Structured output validation (optional for work result)\n- Error handling with retry\n\n## Verification\n- Setup prompts execute first in order\n- Work prompt executes with setup context\n- Wrap-up prompts execute with full context\n- All captured to single JSONL file", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:16.889754Z", "updated_at": "2026-01-20T18:38:53.562732Z", "closed_at": "2026-01-20T18:38:53.562732Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on bookended agent pattern. Will first review existing patterns (walked agent, output capture) to understand dependencies.", "source": "executor", "created_at": "2026-01-20T18:36:29.068646Z"}, {"content": "Implemented BookendedAgent with full test coverage. All 24 new tests pass, and the entire soda test suite (143 tests) passes. Implementation includes: setup prompts \u2192 work prompt \u2192 wrapup prompts execution order, context persistence across all phases, BookendedResult with setup_responses/work_response/wrapup_responses, JSONL output capture with agent_type='bookended', optional structured output validation for work response.", "source": "executor", "created_at": "2026-01-20T18:38:37.013041Z"}]}
{"id": "ralph-16h8y0", "title": "Implement structured output validation", "description": "Create Pydantic-based structured output validation for agent responses.\n\n## Requirements\n- Parse agent output against expected Pydantic schema\n- Return typed object on successful validation\n- Raise detailed validation error on schema mismatch\n- System halts on validation failure (no retry at agent level)\n\n## Interface\n```python\nclass StructuredOutputValidator:\n    def validate(self, raw_output: str, schema: Type[BaseModel]) -> T:\n        \"\"\"Validate raw output against schema, return typed object or raise.\"\"\"\n```\n\n## Verification\n- Valid output returns typed Pydantic model\n- Invalid output raises ValidationError with field details\n- Validation errors include what was expected vs received", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:14.656197Z", "updated_at": "2026-01-20T17:56:35.010322Z", "closed_at": "2026-01-20T17:56:35.010322Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on structured output validation. First, exploring existing codebase structure to understand where this should be placed.", "source": "executor", "created_at": "2026-01-20T17:54:45.055597Z"}, {"content": "Implementation complete. Created src/soda/validation.py with:\n- StructuredOutputValidator class with validate(raw_output, schema) method\n- StructuredOutputValidationError exception with detailed error info\n- Proper extraction of field paths for nested schemas\n- Handling of JSON parse errors\n\nAll 14 tests in test_structured_output_validator.py pass. Tests cover:\n- Valid JSON returns typed Pydantic model\n- Missing required fields raise validation errors\n- Wrong field types raise validation errors\n- Invalid JSON raises validation errors\n- Nested schemas validated correctly\n- Error includes field path and received value\n- Optional fields and defaults work correctly", "source": "executor", "created_at": "2026-01-20T17:56:17.873738Z"}]}
{"id": "ralph-19o12l", "title": "Scaffold Soda state layer package structure", "description": "Create the basic package structure for Soda state management:\n\n## Files to Create\n- src/soda/state/__init__.py - Package exports\n- src/soda/state/models.py - Data models (Run, Iteration, AgentOutput, HumanInput)\n- src/soda/state/db.py - SQLite database operations\n- src/soda/project.py - Project identification and path management\n- tests/soda/state/__init__.py - Test package\n\n## Verification\n- Package imports work: from soda.state import models, db\n- from soda.project import ... works\n- uv run pytest tests/soda/ collects test files\n\n## Notes\n- Follow Ralph2 patterns from src/ralph2/state/ and src/ralph2/project.py\n- Use .soda-id file and ~/.soda/projects/<id>/ paths (not .ralph2-)\n- Database file: soda.db (not ralph2.db)", "status": "closed", "priority": 2, "created_at": "2026-01-20T20:15:53.018475Z", "updated_at": "2026-01-20T20:24:28.919430Z", "closed_at": "2026-01-20T20:24:28.919430Z", "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": [{"content": "Starting scaffold work for Soda state layer package structure", "source": "executor", "created_at": "2026-01-20T20:21:39.873427Z"}, {"content": "Scaffolding complete. Created all required files:\n- src/soda/state/__init__.py - exports SodaDB, Run, Iteration, AgentOutput, HumanInput\n- src/soda/state/models.py - data models with to_dict() methods\n- src/soda/state/db.py - SQLite operations with full CRUD for all models\n- src/soda/project.py - project ID, paths, memory, gitignore, ProjectContext class\n- tests/soda/state/__init__.py - test package ready\n\nVerified:\n- from soda.state import models, db - works\n- from soda.project import ProjectContext - works\n- uv run pytest tests/soda/ collects 136 tests, 135 pass (1 unrelated flaky test)\n\nChanges committed to feature/soda-milestone-2-state-layer", "source": "executor", "created_at": "2026-01-20T20:24:25.528147Z"}]}
{"id": "ralph-1a8097", "title": "Planner: Add investigation task guidance", "description": "Planner prompt should include guidance for creating investigation/spike tasks when root cause is unclear. Pattern: When same criterion fails 2+ iterations with similar errors, don't assign another fix - assign investigation first. Investigation is valid Executor work. After root cause is known, Planner can decide: fix or deprioritize. This is standard agile practice.", "status": "closed", "priority": 2, "created_at": "2026-01-18T16:03:32.227868Z", "updated_at": "2026-01-19T15:15:35.316275Z", "closed_at": "2026-01-19T15:15:35.316275Z", "dependencies": [{"depends_on_id": "ralph-1c9p4g", "type": "parent"}], "comments": [{"content": "## Code Analysis\n\n**File to modify:**\n- `src/ralph2/agents/planner.py` - Add investigation guidance to system prompt\n\n**Current state:**\n- Planner prompt has \"Task Decomposition\" section (lines 48-55) but no mention of investigation tasks\n- No guidance on when to create investigation vs fix tasks\n\n**Implementation steps:**\n\n1. Add new section to `PLANNER_SYSTEM_PROMPT` after \"Task Decomposition\" (~line 55):\n\n```python\n## Investigation Tasks\n\nWhen root cause is unclear, assign investigation before fixes:\n\n**Pattern to recognize:**\n- Same criterion fails 2+ iterations with similar errors\n- Executor reports \"Blocked\" or \"Uncertain\" without clear path forward\n- Verifier says \"unverifiable\" but no clear reason why\n\n**When this happens:**\n1. Do NOT assign another fix attempt\n2. Create an investigation task: \"Investigate: why does X fail?\"\n3. Investigation is valid Executor work (see below)\n4. After root cause is known, decide: fix or deprioritize\n\n**Investigation task template:**\n- Title: \"Investigate: <symptom>\"\n- Description: \"Root cause unknown. Previous attempts: <list>. Goal: identify why <X> happens and recommend fix approach.\"\n\nThis is standard agile practice: spikes before implementation when requirements are unclear.\n```\n\n**Test:** Create a spec with a tricky test case, let it fail 2 iterations, verify Planner creates investigation task on iteration 3.", "source": "engineer", "created_at": "2026-01-19T15:09:10.376970Z"}]}
{"id": "ralph-1c9p4g", "title": "Agent role clarity and iteration awareness", "description": "Refine agent responsibilities and add iteration history visibility to improve multi-iteration problem solving. Root issue: Planner couldn't recognize recurring failures because it only sees last iteration, and Executors were declaring 'Completed' without verification.", "status": "closed", "priority": 2, "created_at": "2026-01-18T16:03:22.345586Z", "updated_at": "2026-01-19T15:15:52.928371Z", "closed_at": "2026-01-19T15:15:52.928371Z", "dependencies": [], "comments": [{"content": "## Handoff Summary (2026-01-19)\n\n### Context\nDiscussed conceptually whether these should be structural changes (multi-step orchestrator) or prompt fixes. Conclusion: **prompt fixes are the right approach** for now. The multi-step orchestrator idea was deferred - see ralph-i5rcqp for future work on capturing step patterns.\n\n### Approach\nAll remaining work is prompt/data changes to existing agents. No architectural changes needed.\n\n### Children Status\n- **ralph-dyjo23** (Planner iteration history) - DATA + PROMPT - detailed implementation in comments\n- **ralph-1a8097** (Planner investigation guidance) - PROMPT only - detailed implementation in comments  \n- **ralph-7ctr57** (Executor completion clarity) - PROMPT only - detailed implementation in comments\n- **ralph-usxwlr** (Verifier scope) - CLOSED - already implemented in feature/verifier-assessor-refactor\n- **ralph-41jjlp** (Executor investigation work) - PROMPT only - detailed implementation in comments\n\n### Key Files\n- `src/ralph2/agents/planner.py` - Planner system prompt and run_planner()\n- `src/ralph2/agents/executor.py` - Executor system prompt\n- `src/ralph2/runner.py` - Orchestration, needs to build iteration history\n\n### Testing\nEach child issue has a test approach in its comments. Run `uv run pytest tests/ -v` after changes.\n\n### Related\n- ralph-i5rcqp: Future work on capturing agent step patterns for meta-analysis", "source": "engineer", "created_at": "2026-01-19T15:11:15.113788Z"}, {"content": "## Implementation Complete (2026-01-19)\n\nAll children implemented and tested:\n\n### Planner Changes (planner.py)\n- Added **Pattern Recognition** section to system prompt - helps identify recurring failures\n- Added **Investigation Tasks** section to system prompt - guides when to create investigation vs fix tasks\n- Added `iteration_history` parameter to `run_planner()` function\n- Updated prompt building to include iteration history for pattern recognition\n\n### Executor Changes (executor.py)  \n- Added **CRITICAL: What 'Completed' Means** section - clarifies Completed = tests run and pass\n- Added **Investigation Tasks** section - explains investigation work is valid and how to do it\n- Updated **Valid Exit Conditions** to reinforce: Blocked is preferred over Completed without verification\n\n### Runner Changes (runner.py)\n- Added `_build_iteration_history()` method to build summary of previous iterations\n- Updated `_run_planner_with_retry()` to build and pass iteration history\n\n### Tests\n- All 340 ralph2 tests pass\n- Updated 4 tests in `test_planner_error_handling.py` to mock the new iteration history building\n\n### Files Modified\n- `src/ralph2/agents/planner.py` (system prompt + function signature + prompt building)\n- `src/ralph2/agents/executor.py` (system prompt)\n- `src/ralph2/runner.py` (iteration history building)\n- `tests/ralph2/test_planner_error_handling.py` (test fixes)", "source": "executor", "created_at": "2026-01-19T15:15:49.910887Z"}]}
{"id": "ralph-1d4ru1", "title": "Implement narrow agent pattern", "description": "Create src/soda/agents/narrow.py implementing the narrow agent pattern.\n\n## Class: NarrowAgent\n```python\nclass NarrowAgent:\n    def invoke(\n        self,\n        prompt: str,\n        output_schema: Type[BaseModel],\n        allowed_tools: Optional[List[str]] = None\n    ) -> T:  # Returns instance of output_schema\n```\n\n## Requirements:\n- Accept prompt and expected output schema\n- Optionally restrict to tool allowlist\n- Return structured output matching schema\n- Capture full conversation to JSONL file\n- Use RetryHandler for transient errors\n- Use StructuredOutputValidator for output validation\n\n## Tests:\n- tests/soda/test_narrow_agent.py\n- Test basic invocation with schema\n- Test tool allowlist restriction\n- Test conversation capture\n- Test retry on transient errors\n\n## Depends on: Foundation modules (errors.py, validation.py, capture.py)", "status": "closed", "priority": 1, "created_at": "2026-01-20T18:29:46.175659Z", "updated_at": "2026-01-20T18:35:58.843353Z", "closed_at": "2026-01-20T18:35:58.843353Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": []}
{"id": "ralph-1dbbg8", "title": "Soda Milestone 2: State Layer", "description": "# Soda State Layer\n\nImplement persistent state management for Soda that provides continuity across stateless agent invocations. This includes:\n\n## Core Modules\n- Project management (.soda-id, project directories at ~/.soda/projects/<id>/)\n- Database operations (SQLite for Run, Iteration, AgentOutput, HumanInput)\n- Memory management (memory.md read/write with 50KB warning)\n- Trace integration (trc CLI wrapper for work tracking)\n- Git operations (branch management, code state reading)\n- Human input handling (store, read pending, mark consumed)\n\n## References\n- Ralph2 state implementation: src/ralph2/state/\n- Ralph2 project management: src/ralph2/project.py\n- Database location: ~/.soda/projects/<project-id>/soda.db", "status": "open", "priority": 2, "created_at": "2026-01-20T20:15:44.546935Z", "updated_at": "2026-01-20T20:15:44.546935Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-1drhdw", "title": "Implement Soda project management", "description": "Create project identification and path management in src/soda/project.py:\n\n## Functions\n- get_project_id(project_root) - Get/create UUID from .soda-id file\n- get_project_state_dir(project_id) - ~/.soda/projects/<id>/\n- get_project_db_path(project_id) - path to soda.db\n- read_memory(project_id) - Read memory.md (empty string if not exists)\n- write_memory(project_id, content) - Write to memory.md\n- ProjectContext class - Encapsulates paths and IDs\n\n## Spec Criteria\n- WHEN Soda runs without .soda-id, THEN create new UUID and store\n- WHEN .soda-id exists, THEN use existing project ID\n- WHEN project initialized, THEN create ~/.soda/projects/<project-id>/\n- WHEN .soda-id exists but project dir missing, THEN recreate dir\n\n## Tests\n- Create tests/soda/test_project.py\n- Test atomic .soda-id creation\n- Test directory creation/recreation\n- Test memory read/write\n\nReference: src/ralph2/project.py", "status": "closed", "priority": 2, "created_at": "2026-01-20T20:16:07.887738Z", "updated_at": "2026-01-20T20:30:02.523981Z", "closed_at": "2026-01-20T20:30:02.523981Z", "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-1ejs7m", "title": "Implement output capture module", "description": "Create the output capture module that saves agent outputs to JSONL files.\n\n## Requirements\n- Save raw output to outputs/ directory\n- Include timestamp, agent type, and prompt summary in each record\n- JSONL format (one JSON object per line, append-friendly)\n- Non-blocking: capture failures must not affect agent result return\n\n## Interface\n```python\nclass OutputCapture:\n    def capture(self, agent_type: str, prompt_summary: str, output: Any) -> None:\n        \"\"\"Capture agent output to JSONL file. Non-blocking, swallows errors.\"\"\"\n```\n\n## Verification\n- Calling capture() creates/appends to JSONL file\n- File contains timestamp, agent_type, prompt_summary\n- If capture fails, no exception is raised", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:13.969795Z", "updated_at": "2026-01-20T17:56:30.819979Z", "closed_at": "2026-01-20T17:56:30.819979Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on output capture module. Exploring codebase structure.", "source": "executor", "created_at": "2026-01-20T17:54:44.125197Z"}, {"content": "Completed implementation:\n- Created OutputCapture class in src/soda/outputs/capture.py\n- Updated src/soda/outputs/__init__.py to export OutputCapture\n- Created comprehensive test suite (19 tests) in tests/soda/test_output_capture.py\n- All tests pass\n\nImplementation features:\n- Saves to outputs/ directory by default (configurable via output_dir parameter)\n- JSONL format with timestamp, agent_type, prompt_summary, and output fields\n- Non-blocking: swallows all errors (file, JSON, directory creation)\n- Date-based filenames (agent_outputs_YYYY-MM-DD.jsonl) for organization\n- Appends to existing files for multiple captures", "source": "executor", "created_at": "2026-01-20T17:56:27.873339Z"}]}
{"id": "ralph-1flgpo", "title": "src/ralph2/runner.py:40-103: Functions _extract_spec_title() and slugify_spec_title() lack test coverage and could be moved to a utility module. These utility functions handle spec parsing and branch name generation but are not independently testable. They're implementation details mixed with orchestration logic.. Move to a dedicated utils.py module with unit tests, or add tests that verify edge cases (empty specs, special characters, unicode).", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/runner.py:40-103: Functions _extract_spec_title() and slugify_spec_title() lack test coverage and could be moved to a utility module. These utility functions handle spec parsing and branch name generation but are not independently testable. They're implementation details mixed with orchestration logic.. Move to a dedicated utils.py module with unit tests, or add tests that verify edge cases (empty specs, special characters, unicode).", "status": "open", "priority": 2, "created_at": "2026-01-20T17:53:26.836049Z", "updated_at": "2026-01-20T17:53:26.836049Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-1fmlq4", "title": "Implement structured output validation", "description": "Create src/soda/validation.py for Pydantic schema validation.\n\n## Classes:\n- StructuredOutputValidationError(Exception): Raised when validation fails\n- StructuredOutputValidator: Validates agent output against Pydantic schemas\n\n## Methods:\n- validate(output: str | dict, schema: Type[BaseModel]) -> BaseModel\n- If valid: returns parsed Pydantic model instance\n- If invalid: raises StructuredOutputValidationError with details\n\n## Requirements:\n- Parse JSON if string input\n- Validate against Pydantic model\n- Include detailed error messages on failure\n- System halts on validation failure (no retry)\n\n## Tests:\n- tests/soda/test_validation.py\n- Test valid schema validation\n- Test invalid schema raises error\n- Test error message includes details\n\n## Depends on: Scaffolding complete (ralph-fs2dsc)", "status": "closed", "priority": 1, "created_at": "2026-01-20T18:29:36.014730Z", "updated_at": "2026-01-20T18:35:58.842964Z", "closed_at": "2026-01-20T18:35:58.842964Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": []}
{"id": "ralph-1g8li1", "title": "Implement walked agent pattern", "description": "Create the walked agent pattern - maintains conversation context across multiple prompts.\n\n## Requirements\n- Start a conversation that persists context\n- Send subsequent prompts to same agent context\n- Capture each response in sequence\n- End conversation and capture full transcript to JSONL\n\n## Interface\n```python\nclass WalkedAgent:\n    def start(self) -> None:\n        \"\"\"Start a walked conversation.\"\"\"\n        \n    def send(self, prompt: str) -> str:\n        \"\"\"Send prompt to existing context, return response.\"\"\"\n        \n    def end(self) -> List[Message]:\n        \"\"\"End conversation, capture to JSONL, return full transcript.\"\"\"\n```\n\n## Dependencies\n- Output capture module\n- Error handling with retry\n\n## Verification\n- Context persists: agent remembers previous exchanges\n- Each response captured in sequence\n- Full conversation written to JSONL on end()", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:16.217854Z", "updated_at": "2026-01-20T18:04:14.290875Z", "closed_at": "2026-01-20T18:04:14.290875Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on walked agent pattern. Exploring existing codebase structure.", "source": "executor", "created_at": "2026-01-20T18:01:58.600393Z"}, {"content": "Implementation complete. Created WalkedAgent class with start(), send(), and end() methods. All 20 tests pass. Context persists across sends, output captured to JSONL on end().", "source": "executor", "created_at": "2026-01-20T18:04:00.521609Z"}]}
{"id": "ralph-1hm1j2", "title": "src/soda/outputs/capture.py:67,74: Two separate datetime.now() calls for timestamp and filename could cause misalignment across midnight boundary.. If capture() is called at 23:59:59.999 UTC, the record timestamp might show one date while the filename shows the next date, making logs harder to correlate.. Capture datetime.now(timezone.utc) once at the start and derive both timestamp and filename from the same value.", "description": "Feedback from code_reviewer:\n\nsrc/soda/outputs/capture.py:67,74: Two separate datetime.now() calls for timestamp and filename could cause misalignment across midnight boundary.. If capture() is called at 23:59:59.999 UTC, the record timestamp might show one date while the filename shows the next date, making logs harder to correlate.. Capture datetime.now(timezone.utc) once at the start and derive both timestamp and filename from the same value.", "status": "open", "priority": 2, "created_at": "2026-01-20T18:48:03.469978Z", "updated_at": "2026-01-20T18:48:03.469978Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1w1g1o", "type": "parent"}], "comments": []}
{"id": "ralph-1hmoq9", "title": "src/ralph2/milestone.py:43-79: Function _get_open_children() has duplicate subprocess calls for each child - first to get the tree, then individual 'trc show' for each child's description.. O(n) subprocess calls for n children can be slow and inefficient, especially with many work items.. Consider batching the 'trc show' calls or requesting all needed data upfront if trc supports bulk queries.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/milestone.py:43-79: Function _get_open_children() has duplicate subprocess calls for each child - first to get the tree, then individual 'trc show' for each child's description.. O(n) subprocess calls for n children can be slow and inefficient, especially with many work items.. Consider batching the 'trc show' calls or requesting all needed data upfront if trc supports bulk queries.", "status": "open", "priority": 3, "created_at": "2026-01-20T18:08:50.528107Z", "updated_at": "2026-01-20T18:08:50.528107Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1w1g1o", "type": "parent"}], "comments": []}
{"id": "ralph-1hraa1", "title": "src/ralph2/feedback.py:77-109: Function parse_feedback_item() lacks validation for malformed priority markers. The regex r'\\[P([0-4])\\]\\s*(.*)' will silently ignore malformed markers like '[P5]' or '[P-1]', defaulting to P2. This could hide data quality issues in specialist feedback.. Add logging or validation for unexpected priority formats to make issues visible during development/debugging.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/feedback.py:77-109: Function parse_feedback_item() lacks validation for malformed priority markers. The regex r'\\[P([0-4])\\]\\s*(.*)' will silently ignore malformed markers like '[P5]' or '[P-1]', defaulting to P2. This could hide data quality issues in specialist feedback.. Add logging or validation for unexpected priority formats to make issues visible during development/debugging.", "status": "open", "priority": 3, "created_at": "2026-01-20T17:53:27.049307Z", "updated_at": "2026-01-20T17:53:27.049307Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-1j7knr", "title": "src/soda/agents/bookended.py:216-221: Silent exception swallowing in BookendedAgent._capture_output() with bare `except Exception: pass` block, same pattern as other agents.. Debugging will be difficult when output capture silently fails. While non-blocking capture is correct behavior, completely swallowing errors hides potential issues during development. Note: ralph-krho34 tracks this for narrow.py, walked.py, and capture.py but BookendedAgent was added later and has the same issue.. Add optional logging (e.g., `logging.debug('Output capture failed: %s', e)`) inside the exception handler to aid debugging while maintaining non-blocking behavior.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/bookended.py:216-221: Silent exception swallowing in BookendedAgent._capture_output() with bare `except Exception: pass` block, same pattern as other agents.. Debugging will be difficult when output capture silently fails. While non-blocking capture is correct behavior, completely swallowing errors hides potential issues during development. Note: ralph-krho34 tracks this for narrow.py, walked.py, and capture.py but BookendedAgent was added later and has the same issue.. Add optional logging (e.g., `logging.debug('Output capture failed: %s', e)`) inside the exception handler to aid debugging while maintaining non-blocking behavior.", "status": "open", "priority": 3, "created_at": "2026-01-20T20:01:56.798867Z", "updated_at": "2026-01-20T20:01:56.798867Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-1jv89t", "title": "src/soda/validation.py:129: Type hint uses lowercase 'any' instead of 'Any' from typing module. Inconsistent with the rest of the codebase which uses proper typing imports. This could cause type checking failures with strict type checkers like mypy.. Change the return type annotation from 'any' to 'Any' and ensure it's imported from typing module", "description": "Feedback from code_reviewer:\n\nsrc/soda/validation.py:129: Type hint uses lowercase 'any' instead of 'Any' from typing module. Inconsistent with the rest of the codebase which uses proper typing imports. This could cause type checking failures with strict type checkers like mypy.. Change the return type annotation from 'any' to 'Any' and ensure it's imported from typing module", "status": "open", "priority": 2, "created_at": "2026-01-20T20:28:42.418134Z", "updated_at": "2026-01-20T20:28:42.418134Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1ke8mm", "title": "src/soda/errors.py:261-282: _calculate_delay() method is duplicated logic between sync and async retry execution paths.. Low impact since it's just delay calculation, but if the delay algorithm changes, it could be updated in one place. The current code is DRY (uses the shared method), but there's no test coverage specifically for _calculate_delay().. Add unit tests for _calculate_delay() to verify exponential backoff math independently of the retry loop.", "description": "Feedback from code_reviewer:\n\nsrc/soda/errors.py:261-282: _calculate_delay() method is duplicated logic between sync and async retry execution paths.. Low impact since it's just delay calculation, but if the delay algorithm changes, it could be updated in one place. The current code is DRY (uses the shared method), but there's no test coverage specifically for _calculate_delay().. Add unit tests for _calculate_delay() to verify exponential backoff math independently of the retry loop.", "status": "open", "priority": 3, "created_at": "2026-01-20T18:48:03.576849Z", "updated_at": "2026-01-20T18:48:03.576849Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-1kk0qf", "title": "Implement BookendedAgent (re-do after worktree merge failure)", "description": "BookendedAgent implementation was lost in worktree merge. Need to re-implement.\n\n## Requirements\n- Execute setup prompts before main work prompt\n- Execute main work prompt in same context  \n- Execute wrap-up prompts after main work\n- Capture full conversation (setup + work + wrap-up) to JSONL\n\n## Implementation Pattern (follow WalkedAgent)\n- Create src/soda/agents/bookended.py\n- Use _invoke_agent() as mockable hook for testing\n- Maintain message context across all phases\n- Return BookendedResult with setup/work/wrapup responses\n\n## Tests\n- Create tests/soda/test_bookended_agent.py\n- Test setup execution order\n- Test context persistence across phases\n- Test JSONL output capture\n\n## Export\n- Add BookendedAgent to src/soda/agents/__init__.py", "status": "closed", "priority": 2, "created_at": "2026-01-20T19:56:12.875556Z", "updated_at": "2026-01-20T19:58:21.005033Z", "closed_at": "2026-01-20T19:58:21.005033Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting BookendedAgent implementation. Will follow WalkedAgent pattern for context persistence.", "source": "executor", "created_at": "2026-01-20T19:56:30.467910Z"}, {"content": "Completed BookendedAgent implementation:\n- Created src/soda/agents/bookended.py with BookendedAgent class and BookendedResult dataclass\n- Implemented run() method that maintains context across setup, work, and wrapup phases\n- Added _invoke_agent() as mockable hook (same pattern as WalkedAgent)\n- Added JSONL output capture with agent_type='bookended'\n- Created tests/soda/test_bookended_agent.py with 17 comprehensive tests\n- Exported BookendedAgent from soda.agents module\n- All 136 soda tests pass\n- Changes committed to feature branch", "source": "executor", "created_at": "2026-01-20T19:58:17.140174Z"}]}
{"id": "ralph-1kt69h", "title": "src/soda/outputs/capture.py:67,74: Two datetime.now() calls in capture() method could produce different timestamps. The record timestamp and the filename date could theoretically be different if capture() is called at exactly midnight UTC, causing a slight inconsistency between record metadata and file organization.. Call datetime.now(timezone.utc) once at the start of capture() and reuse the value for both the record timestamp and file path", "description": "Feedback from code_reviewer:\n\nsrc/soda/outputs/capture.py:67,74: Two datetime.now() calls in capture() method could produce different timestamps. The record timestamp and the filename date could theoretically be different if capture() is called at exactly midnight UTC, causing a slight inconsistency between record metadata and file organization.. Call datetime.now(timezone.utc) once at the start of capture() and reuse the value for both the record timestamp and file path", "status": "open", "priority": 3, "created_at": "2026-01-20T20:28:42.590621Z", "updated_at": "2026-01-20T20:28:42.590621Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1mr57j", "title": "Rebuild soda package from scratch (lost in worktree issue)", "description": "## CRITICAL: Previous Work Lost\n\nAll soda work from iterations 1-3 was lost due to worktree merge failure. The executors completed their work in isolated worktrees, but changes were never merged back to the main branch. Only orphaned .pyc files remained.\n\n## What must be rebuilt\n\n### 1. Project Scaffolding\n- src/soda/__init__.py\n- src/soda/types.py (Pydantic models: AgentConfig, StructuredOutput, etc.)\n- src/soda/agents/__init__.py\n- src/soda/outputs/__init__.py\n- tests/soda/test_scaffolding.py\n\n### 2. Foundation Modules\n- src/soda/errors.py (TransientError, FatalError, MaxRetriesExhaustedError, is_transient_error(), RetryHandler)\n- src/soda/validation.py (StructuredOutputValidator, StructuredOutputValidationError)\n- src/soda/outputs/capture.py (OutputCapture - JSONL, non-blocking, date-based filenames)\n- Tests for all foundation modules\n\n### 3. Narrow Agent\n- src/soda/agents/narrow.py (NarrowAgent class)\n- Support for prompt, output_schema, optional tools\n- JSONL conversation capture\n- Integration with RetryHandler\n- Tests\n\n### 4. Walked Agent\n- src/soda/agents/walked.py (WalkedAgent class)\n- start(), send(), end() pattern\n- Context persistence across sends\n- JSONL capture on end()\n- Tests\n\n## Verification\n- All imports work (soda, soda.agents, soda.outputs)\n- All tests pass\n- Files are actually committed to git (check with git status)\n\n## IMPORTANT\nAfter completing work, VERIFY files exist with:\n```\nfind src/soda -name '*.py' | head -20\ngit status\n```", "status": "closed", "priority": 0, "created_at": "2026-01-20T18:10:18.609848Z", "updated_at": "2026-01-20T18:29:18.938842Z", "closed_at": "2026-01-20T18:29:18.938842Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting rebuild work. Current state: src/soda exists with empty agents/ and outputs/ directories but no .py files. Need to create all modules from scratch.", "source": "executor", "created_at": "2026-01-20T18:11:12.082423Z"}]}
{"id": "ralph-1mvqd0", "title": "src/soda/agents/narrow.py:116: Claude SDK import is inline within method rather than at module level with optional import handling. Makes it harder to mock the SDK for testing and adds import overhead on every agent call. The SDK availability check happens at runtime within the hot path.. Consider moving SDK import to module level with try/except for optional import, or document that the inline import is intentional for lazy loading", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/narrow.py:116: Claude SDK import is inline within method rather than at module level with optional import handling. Makes it harder to mock the SDK for testing and adds import overhead on every agent call. The SDK availability check happens at runtime within the hot path.. Consider moving SDK import to module level with try/except for optional import, or document that the inline import is intentional for lazy loading", "status": "open", "priority": 3, "created_at": "2026-01-20T20:28:42.647972Z", "updated_at": "2026-01-20T20:28:42.647972Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1npgah", "title": "src/ralph2/runner.py:776-800: Magic strings for error classification scattered across method _is_recoverable_error(). The recoverable and fatal error patterns are hardcoded string lists that make the error classification logic brittle and hard to maintain. Adding new error patterns requires modifying the method directly.. Extract error patterns to module-level constants (e.g., RECOVERABLE_ERROR_PATTERNS, FATAL_ERROR_PATTERNS) that can be easily extended and tested independently.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/runner.py:776-800: Magic strings for error classification scattered across method _is_recoverable_error(). The recoverable and fatal error patterns are hardcoded string lists that make the error classification logic brittle and hard to maintain. Adding new error patterns requires modifying the method directly.. Extract error patterns to module-level constants (e.g., RECOVERABLE_ERROR_PATTERNS, FATAL_ERROR_PATTERNS) that can be easily extended and tested independently.", "status": "open", "priority": 2, "created_at": "2026-01-20T17:53:26.779636Z", "updated_at": "2026-01-20T17:53:26.779636Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-1r9u2q", "title": "Documentation", "description": "Remaining documentation work from completed milestone", "status": "open", "priority": 2, "created_at": "2026-01-20T20:03:59.614696Z", "updated_at": "2026-01-20T20:03:59.614696Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-1rvutg", "title": "src/soda/agents/walked.py:63: RetryHandler is initialized but never used in send() method. WalkedAgent has retry_handler as a dependency but doesn't actually wrap _invoke_agent calls with retry logic, making the agent vulnerable to transient failures unlike NarrowAgent which does use retry.. Wrap _invoke_agent call in send() with self._retry_handler.execute_with_retry() to provide consistent error handling across agent patterns", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/walked.py:63: RetryHandler is initialized but never used in send() method. WalkedAgent has retry_handler as a dependency but doesn't actually wrap _invoke_agent calls with retry logic, making the agent vulnerable to transient failures unlike NarrowAgent which does use retry.. Wrap _invoke_agent call in send() with self._retry_handler.execute_with_retry() to provide consistent error handling across agent patterns", "status": "open", "priority": 2, "created_at": "2026-01-20T20:28:42.475673Z", "updated_at": "2026-01-20T20:28:42.475673Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-1rwvxk", "title": "src/ralph2/agents/executor.py:250-273: Functions _check_uncommitted_changes() and _auto_commit_changes() have inconsistent error handling. _check_uncommitted_changes() silently returns False on any exception, while _auto_commit_changes() has no try/except and could raise unexpected errors.. Inconsistent error handling can lead to silent failures or unexpected crashes. If git commands fail for unusual reasons, the code may behave unpredictably.. Make error handling consistent across both functions. Either both should have try/except with logging, or both should propagate errors. Consider using a shared _run_git_command_safe() helper.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/agents/executor.py:250-273: Functions _check_uncommitted_changes() and _auto_commit_changes() have inconsistent error handling. _check_uncommitted_changes() silently returns False on any exception, while _auto_commit_changes() has no try/except and could raise unexpected errors.. Inconsistent error handling can lead to silent failures or unexpected crashes. If git commands fail for unusual reasons, the code may behave unpredictably.. Make error handling consistent across both functions. Either both should have try/except with logging, or both should propagate errors. Consider using a shared _run_git_command_safe() helper.", "status": "open", "priority": 2, "created_at": "2026-01-20T18:08:50.313803Z", "updated_at": "2026-01-20T18:08:50.313803Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
{"id": "ralph-1tbdk4", "title": "Soda M1: Agent Infrastructure", "description": "# Soda Milestone 1: Agent Infrastructure\n\nFoundation layer for Soda that can invoke Claude agents in different patterns (narrow, walked, bookended) and handle their structured outputs reliably.\n\n## Acceptance Criteria\n\n### Narrow Agent Pattern\n- WHEN a narrow agent is invoked with a prompt and expected output schema, THEN it returns structured output matching the schema\n- WHEN a narrow agent is invoked with a tool allowlist, THEN the agent only has access to those tools\n- WHEN a narrow agent completes, THEN its full conversation is captured to a JSONL file\n\n### Walked Agent Pattern\n- WHEN a walked conversation is started, THEN subsequent prompts are sent to the same agent context\n- WHEN multiple prompts are sent to a walked agent, THEN each response is captured in sequence\n- WHEN a walked conversation is ended, THEN the full conversation is captured to a JSONL file\n\n### Bookended Agent Pattern\n- WHEN a bookended agent is invoked, THEN setup prompts execute before the main work prompt\n- WHEN main work completes, THEN wrap-up prompts execute in the same context\n- WHEN wrap-up completes, THEN the full conversation (setup + work + wrap-up) is captured\n\n### Structured Output\n- WHEN an agent returns output matching the expected schema, THEN the output is parsed and returned as a typed object\n- WHEN an agent returns output not matching the schema, THEN a validation error is raised with details\n- WHEN schema validation fails, THEN the system halts (does not retry at agent level)\n\n### Error Handling\n- WHEN a transient error occurs (rate limit, timeout, connection error, 5xx), THEN the system retries with exponential backoff (max 3 attempts)\n- WHEN a fatal error occurs (invalid API key, 401, 403, permission denied), THEN the system halts immediately\n- WHEN max retries are exhausted, THEN the error is surfaced with full context\n- WHEN an unknown error occurs, THEN it is treated as transient (retry)\n\n### Output Capture\n- WHEN any agent invocation completes, THEN raw output is saved to outputs/ directory\n- WHEN output is captured, THEN it includes timestamp, agent type, and prompt summary\n- WHEN output capture fails, THEN the agent result is still returned (capture is non-blocking)\n\n## Technical Constraints\n- Python 3.11+, uv for package management\n- Claude Agent SDK for agent invocations\n- Pydantic for structured output validation\n- JSONL format for output files", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:47:41.179729Z", "updated_at": "2026-01-20T20:03:44.993040Z", "closed_at": "2026-01-20T20:03:44.993040Z", "dependencies": [], "comments": []}
{"id": "ralph-1vsn3x", "title": "Implement walked agent pattern", "description": "Create src/soda/agents/walked.py implementing the walked agent pattern.\n\n## Class: WalkedAgent\n```python\nclass WalkedAgent:\n    def start(self) -> WalkedSession:\n        \"\"\"Start a new conversation, return session handle\"\"\"\n    \n    def send(self, session: WalkedSession, prompt: str) -> str:\n        \"\"\"Send prompt to existing session, return response\"\"\"\n    \n    def end(self, session: WalkedSession) -> WalkedResult:\n        \"\"\"End session, capture to JSONL, return full result\"\"\"\n```\n\n## Requirements:\n- Maintain context across multiple prompts\n- Each response captured in sequence\n- Full conversation captured to JSONL on end()\n- Use RetryHandler for transient errors\n\n## Tests:\n- tests/soda/test_walked_agent.py\n- Test session start/send/end flow\n- Test context persistence across sends\n- Test conversation capture on end\n\n## Depends on: Foundation modules (errors.py, capture.py)", "status": "closed", "priority": 1, "created_at": "2026-01-20T18:29:46.946890Z", "updated_at": "2026-01-20T18:35:58.843731Z", "closed_at": "2026-01-20T18:35:58.843731Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": []}
{"id": "ralph-1w1g1o", "title": "Backlog", "description": "Remaining backlog work from completed milestone", "status": "open", "priority": 2, "created_at": "2026-01-20T20:03:59.721868Z", "updated_at": "2026-01-20T20:03:59.721868Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-1yswcb", "title": "Implement error handling module", "description": "Create src/soda/errors.py with error classification and retry logic.\n\n## Classes to implement:\n- TransientError(Exception): For retriable errors (rate limits, timeouts, 5xx)\n- FatalError(Exception): For non-retriable errors (401, 403, invalid API key)\n- MaxRetriesExhaustedError(Exception): When retries are exhausted\n\n## Functions:\n- is_transient_error(error) -> bool: Classify errors as transient or fatal\n- RetryHandler class with exponential backoff (max 3 attempts)\n\n## Error classification:\n- TRANSIENT: rate limit, timeout, connection error, 5xx, unknown errors\n- FATAL: 401, 403, invalid API key, permission denied\n\n## Tests:\n- tests/soda/test_errors.py\n- Test error classification\n- Test retry handler with mock failures\n\n## Depends on: Scaffolding complete (ralph-fs2dsc)", "status": "closed", "priority": 1, "created_at": "2026-01-20T18:29:34.597633Z", "updated_at": "2026-01-20T18:35:58.842211Z", "closed_at": "2026-01-20T18:35:58.842211Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": []}
{"id": "ralph-2dlpk8", "title": "src/soda/agents/narrow.py:118-119: Tool restriction logic sets allowed_tools to empty list when tools=None: `allowed_tools=tools or []`. This may disable all tools when None is passed, contradicting the docstring that says 'None means all tools'.. Passing tools=None may unexpectedly restrict the agent to no tools instead of allowing all tools as documented. SDK behavior when allowed_tools=[] is unclear.. Verify SDK behavior with empty list vs None. If empty list disables tools, change to `allowed_tools=tools` (pass None directly) or conditionally omit the parameter when None.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/narrow.py:118-119: Tool restriction logic sets allowed_tools to empty list when tools=None: `allowed_tools=tools or []`. This may disable all tools when None is passed, contradicting the docstring that says 'None means all tools'.. Passing tools=None may unexpectedly restrict the agent to no tools instead of allowing all tools as documented. SDK behavior when allowed_tools=[] is unclear.. Verify SDK behavior with empty list vs None. If empty list disables tools, change to `allowed_tools=tools` (pass None directly) or conditionally omit the parameter when None.", "status": "open", "priority": 2, "created_at": "2026-01-20T18:41:36.605257Z", "updated_at": "2026-01-20T18:41:36.605257Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1r9u2q", "type": "parent"}], "comments": []}
{"id": "ralph-2t2et1", "title": "src/soda/agents/bookended.py:74: RetryHandler is initialized but never used in run() method. BookendedAgent has retry_handler as a dependency but doesn't actually wrap _invoke_agent calls with retry logic, making the agent vulnerable to transient failures.. Wrap _invoke_agent calls in _send_prompt() with self._retry_handler.execute_with_retry() to provide consistent error handling", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/bookended.py:74: RetryHandler is initialized but never used in run() method. BookendedAgent has retry_handler as a dependency but doesn't actually wrap _invoke_agent calls with retry logic, making the agent vulnerable to transient failures.. Wrap _invoke_agent calls in _send_prompt() with self._retry_handler.execute_with_retry() to provide consistent error handling", "status": "open", "priority": 2, "created_at": "2026-01-20T20:28:42.533444Z", "updated_at": "2026-01-20T20:28:42.533444Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": []}
{"id": "ralph-3vfi10", "title": "src/ralph2/cli.py:103-131: Function _get_work_item_spec() has fragile string parsing for trc output format. It uses string startswith() checks and positional line parsing which will break if trc output format changes.. CLI functionality depends on undocumented external tool output format. Changes to trc could silently break the feature.. Consider using structured output from trc if available (JSON mode), or add defensive parsing with better error messages when format doesn't match expectations.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/cli.py:103-131: Function _get_work_item_spec() has fragile string parsing for trc output format. It uses string startswith() checks and positional line parsing which will break if trc output format changes.. CLI functionality depends on undocumented external tool output format. Changes to trc could silently break the feature.. Consider using structured output from trc if available (JSON mode), or add defensive parsing with better error messages when format doesn't match expectations.", "status": "open", "priority": 2, "created_at": "2026-01-20T18:08:50.421432Z", "updated_at": "2026-01-20T18:08:50.421432Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-41jjlp", "title": "Executor: Clarify investigation is valid work", "description": "Executor prompt should clarify that investigation/research tasks are valid work. When assigned 'investigate root cause of X', the Executor should: run the failing code, capture full output/traceback, analyze the error chain, identify actual root cause, report findings. This is distinct from 'fix X' tasks. Executors do thorough work - whether that's writing code or researching problems.", "status": "closed", "priority": 2, "created_at": "2026-01-18T16:03:48.002781Z", "updated_at": "2026-01-19T15:15:35.317045Z", "closed_at": "2026-01-19T15:15:35.317045Z", "dependencies": [{"depends_on_id": "ralph-1c9p4g", "type": "parent"}], "comments": [{"content": "## Code Analysis\n\n**File to modify:**\n- `src/ralph2/agents/executor.py` - Add investigation task guidance to system prompt\n\n**Current state:**\n- EXECUTOR_SYSTEM_PROMPT says \"Do ONLY that work\u2014nothing else\" (line 36)\n- No mention that investigation/research tasks are valid work\n- Executor might be confused when assigned \"investigate root cause of X\"\n\n**Implementation steps:**\n\n1. Add new section to `EXECUTOR_SYSTEM_PROMPT` after \"Test-Driven Development\" section (~line 91):\n\n```python\n## Investigation Tasks\n\nInvestigation/research tasks are valid work. When assigned \"Investigate: X\":\n\n**Your deliverable is information, not code:**\n1. Reproduce the issue (run failing code, capture full output/traceback)\n2. Analyze the error chain (what triggers what?)\n3. Identify the actual root cause (not symptoms)\n4. Document findings in a Trace comment\n5. Recommend fix approach (but don't implement unless assigned)\n\n**Investigation output structure:**\n```\n## Findings for: <issue>\n\n**Reproduction:**\n- Command: `<what you ran>`\n- Error: `<exact error message>`\n\n**Root Cause:**\n<explanation of why this happens>\n\n**Recommended Fix:**\n<approach to fix, not full implementation>\n```\n\n**Status after investigation:**\n- Completed = You identified root cause and documented findings\n- Blocked = You cannot reproduce or need external resources\n- Uncertain = Multiple possible causes, need guidance on which to pursue\n```\n\n**Test:** Create an investigation task in Trace, assign to Executor, verify it produces findings rather than trying to write code.", "source": "engineer", "created_at": "2026-01-19T15:09:12.272837Z"}]}
{"id": "ralph-5a2207", "title": "Implement Soda Git operations", "description": "Create Git operations in src/soda/state/git.py:\n\n## Spec Criteria\n- WHEN reading code state, THEN current branch name returned\n- WHEN reading code state, THEN uncommitted changes detected (staged/unstaged)\n- WHEN reading code state, THEN commits since base ref listed\n- WHEN reading code state, THEN diff summary since base ref returned\n- WHEN creating a branch, THEN created from specified base\n- WHEN branch already exists, THEN numbered suffix added (e.g., feature/name-2)\n- WHEN checking out a branch, THEN working tree switches to that branch\n\n## GitClient Class Methods\n- get_current_branch() -> str\n- has_uncommitted_changes() -> bool (staged and unstaged)\n- get_commits_since(base_ref) -> List[CommitInfo]\n- get_diff_summary(base_ref) -> str\n- create_branch(name, base_ref) -> str (actual branch name with suffix if needed)\n- checkout_branch(name) -> None\n\n## Implementation\n- Use subprocess to call git CLI\n- Handle git errors gracefully\n- Support numbered suffix logic for existing branches\n\n## Tests\n- Create tests/soda/state/test_git.py\n- Test with actual git repo (test fixtures)\n- Test branch suffix logic", "status": "open", "priority": 2, "created_at": "2026-01-20T20:16:34.649924Z", "updated_at": "2026-01-20T20:16:34.649924Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-7ctr57", "title": "Executor: Clarify completion means verified", "description": "Executor prompt should clarify: work is 'Completed' only when verified by running tests. If tests can't be run (missing credentials, too slow, etc.), status is 'Blocked' not 'Completed.' Executors should not punt verification to the Verifier. The pattern 'I made a fix but needs verification' should not result in 'Completed' status.", "status": "closed", "priority": 2, "created_at": "2026-01-18T16:03:37.308055Z", "updated_at": "2026-01-19T15:15:35.316708Z", "closed_at": "2026-01-19T15:15:35.316708Z", "dependencies": [{"depends_on_id": "ralph-1c9p4g", "type": "parent"}], "comments": [{"content": "## Code Analysis\n\n**File to modify:**\n- `src/ralph2/agents/executor.py` - Strengthen completion requirements in system prompt\n\n**Current state:**\n- EXECUTOR_SYSTEM_PROMPT line 150-154 defines exit conditions:\n  - \"**Completed**: Work finished, tests pass, changes committed, traces updated\"\n- But this isn't strongly enforced - executors sometimes claim Completed without running tests\n- Lines 99-114 discuss verification boundaries but focus on capability vs behavior distinction\n\n**Implementation steps:**\n\n1. Add explicit section to `EXECUTOR_SYSTEM_PROMPT` after \"Test-Driven Development\" (~line 91):\n\n```python\n## CRITICAL: What \"Completed\" Means\n\n**Completed = Verified by Tests**\n\nYou may ONLY report status \"Completed\" when:\n1. You have written tests for the work (if applicable)\n2. You have RUN the tests (`uv run pytest` or equivalent)\n3. The tests PASS\n\n**If you cannot run tests:**\n- Tests require external resources \u2192 Status: **Blocked**, not Completed\n- Tests are too slow \u2192 Status: **Blocked**, not Completed  \n- No test framework exists \u2192 Status: **Blocked**, not Completed\n\n**The pattern \"I made a fix, needs verification\" = Blocked, NOT Completed**\n\nNever punt verification to the Verifier. The Verifier checks spec satisfaction, not your work quality. You own verification of your own work.\n```\n\n2. Update the \"Valid Exit Conditions\" section (lines 149-154) to reinforce:\n\n```python\n## Valid Exit Conditions\n\n- **Completed**: Tests written, tests run, tests PASS, changes committed\n- **Blocked**: Can't proceed OR can't verify (missing deps, external resources)\n- **Uncertain**: Not sure if approach is correct, need guidance\n```\n\n**Test:** Assign a code task, verify Executor runs tests before claiming Completed.", "source": "engineer", "created_at": "2026-01-19T15:09:10.714046Z"}]}
{"id": "ralph-7qh3lc", "title": "Implement BookendedAgent pattern with tests", "description": "Create src/soda/agents/bookended.py implementing the bookended agent pattern. Must support: setup prompts before main work, wrap-up prompts after main work, full conversation context persistence, JSONL output capture. Follow WalkedAgent pattern for context persistence and _invoke_agent for testability. Export from agents/__init__.py. Create comprehensive tests in tests/soda/test_bookended_agent.py.", "status": "closed", "priority": 2, "created_at": "2026-01-20T18:48:38.618851Z", "updated_at": "2026-01-20T18:51:31.030238Z", "closed_at": "2026-01-20T18:51:31.030238Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "Starting work on BookendedAgent implementation. Will review WalkedAgent first to understand the pattern.", "source": "executor", "created_at": "2026-01-20T18:49:06.783476Z"}, {"content": "Implementation complete. Created:\n- src/soda/agents/bookended.py: BookendedAgent class with setup/main/wrapup phases\n- tests/soda/test_bookended_agent.py: 26 comprehensive tests covering all acceptance criteria\n- Updated src/soda/agents/__init__.py to export BookendedAgent\n\nAll 26 BookendedAgent tests pass. All 145 soda tests pass (no regressions).", "source": "executor", "created_at": "2026-01-20T18:51:14.241206Z"}]}
{"id": "ralph-7uw2af", "title": "src/ralph2/agents/executor.py:629-636: ClaudeAgentOptions construction uses options.tools instead of options.allowed_tools. In _run_executor_with_orchestrator_worktree(), the code references options.tools which may not be the correct attribute name. This could lead to runtime errors if the SDK interface changes.. Verify the correct attribute name is 'allowed_tools' (as used elsewhere) and ensure consistency across all ClaudeAgentOptions constructions.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/agents/executor.py:629-636: ClaudeAgentOptions construction uses options.tools instead of options.allowed_tools. In _run_executor_with_orchestrator_worktree(), the code references options.tools which may not be the correct attribute name. This could lead to runtime errors if the SDK interface changes.. Verify the correct attribute name is 'allowed_tools' (as used elsewhere) and ensure consistency across all ClaudeAgentOptions constructions.", "status": "open", "priority": 3, "created_at": "2026-01-20T17:53:26.997126Z", "updated_at": "2026-01-20T17:53:26.997126Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
{"id": "ralph-86p3ce", "title": "Implement Soda Human Input handling", "description": "Implement human input operations (spans models, db, and possibly a service):\n\n## Spec Criteria\n- WHEN human input provided, THEN stored in database linked to current run\n- WHEN reading human input, THEN pending input for run returned\n- WHEN human input consumed, THEN marked as processed\n\n## HumanInput Model (in models.py)\n- id, run_id, input_type, content, created_at, consumed_at\n\n## Database Operations (in db.py)\n- create_human_input(input) -> HumanInput\n- get_unconsumed_inputs(run_id) -> List[HumanInput]\n- mark_input_consumed(input_id, consumed_at) -> None\n\n## Tests\n- Test input creation linked to run\n- Test pending input retrieval\n- Test consumed marking\n\nNote: This may be covered by other tasks (models, db) but needs explicit verification for spec criteria", "status": "closed", "priority": 2, "created_at": "2026-01-20T20:16:42.156053Z", "updated_at": "2026-01-20T20:30:22.240542Z", "closed_at": "2026-01-20T20:30:22.240542Z", "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-anu236", "title": "src/soda/agents/__init__.py:6-12: Bookended agent pattern is documented but not implemented. The agents module references bookended_agent in the docstring but only exports NarrowAgent and WalkedAgent.. Spec explicitly requires bookended agents (setup + main work + wrap-up pattern). This is a spec compliance gap that blocks Milestone 1 completion.. Create src/soda/agents/bookended.py implementing the BookendedAgent class following the pattern established by NarrowAgent and WalkedAgent. Export it from __init__.py.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/__init__.py:6-12: Bookended agent pattern is documented but not implemented. The agents module references bookended_agent in the docstring but only exports NarrowAgent and WalkedAgent.. Spec explicitly requires bookended agents (setup + main work + wrap-up pattern). This is a spec compliance gap that blocks Milestone 1 completion.. Create src/soda/agents/bookended.py implementing the BookendedAgent class following the pattern established by NarrowAgent and WalkedAgent. Export it from __init__.py.", "status": "closed", "priority": 1, "created_at": "2026-01-20T18:41:36.444225Z", "updated_at": "2026-01-20T18:45:20.185713Z", "closed_at": "2026-01-20T18:45:20.185713Z", "dependencies": [{"depends_on_id": "ralph-1pqntk", "type": "parent"}], "comments": [{"content": "Starting work on BookendedAgent implementation. Will first examine existing NarrowAgent and WalkedAgent patterns to understand the established structure.", "source": "executor", "created_at": "2026-01-20T18:43:14.983858Z"}, {"content": "Completed BookendedAgent implementation:\n\n1. Created src/soda/agents/bookended.py with BookendedAgent class\n2. Added BookendedAgent to exports in soda.agents.__init__.py\n3. Created comprehensive tests (19 tests) in tests/soda/test_bookended_agent.py\n\nThe BookendedAgent follows the pattern established by NarrowAgent and WalkedAgent:\n- Uses RetryHandler for transient error handling\n- Uses OutputCapture for JSONL output\n- Supports custom AgentConfig\n- Has _invoke_agent method that can be mocked for testing\n\nKey features:\n- run() method takes setup_prompts, main_prompt, wrapup_prompts\n- All phases share conversation context\n- Returns BookendedResult with main_response and all messages\n- Output capture includes all phases (setup + main + wrapup)\n\nAll 138 soda tests pass.", "source": "executor", "created_at": "2026-01-20T18:45:16.682591Z"}]}
{"id": "ralph-ax4wli", "title": "src/ralph2/agents/executor.py:433-472: Function _gather_efficiency_notes() creates a new ClaudeAgentOptions with hardcoded values instead of properly deriving from the original options.. If the original options have special settings (model overrides, permission modes), they may be lost when gathering efficiency notes, leading to inconsistent behavior.. Derive the reflection_options from the original options, only overriding allowed_tools and system_prompt, preserving model, permission_mode, and other settings.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/agents/executor.py:433-472: Function _gather_efficiency_notes() creates a new ClaudeAgentOptions with hardcoded values instead of properly deriving from the original options.. If the original options have special settings (model overrides, permission modes), they may be lost when gathering efficiency notes, leading to inconsistent behavior.. Derive the reflection_options from the original options, only overriding allowed_tools and system_prompt, preserving model, permission_mode, and other settings.", "status": "open", "priority": 3, "created_at": "2026-01-20T18:08:50.474903Z", "updated_at": "2026-01-20T18:08:50.474903Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-bxwqor", "title": "src/ralph2/milestone.py:84-133: Function _categorize_work_items() has hardcoded keyword lists that may not cover all cases. The categorization logic uses static keyword lists ('feature', 'bug', 'refactor', 'docs') that may miss legitimate categories or miscategorize items. The 'Backlog' catch-all category hides classification failures.. Consider making keywords configurable or add a smarter heuristic. At minimum, add logging when items fall to Backlog so categorization gaps can be identified.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/milestone.py:84-133: Function _categorize_work_items() has hardcoded keyword lists that may not cover all cases. The categorization logic uses static keyword lists ('feature', 'bug', 'refactor', 'docs') that may miss legitimate categories or miscategorize items. The 'Backlog' catch-all category hides classification failures.. Consider making keywords configurable or add a smarter heuristic. At minimum, add logging when items fall to Backlog so categorization gaps can be identified.", "status": "open", "priority": 2, "created_at": "2026-01-20T17:53:26.891775Z", "updated_at": "2026-01-20T17:53:26.891775Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-djjilq", "title": "src/ralph2/runner.py:1431-1467: Method_write_summary() has no error handling for file write operations.. If the summary file cannot be written (permissions, disk full), the error propagates up and could interrupt the run completion flow.. Wrap file operations in try/except and log warnings rather than failing. Summary writing should be non-blocking like other output capture.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/runner.py:1431-1467: Method_write_summary() has no error handling for file write operations.. If the summary file cannot be written (permissions, disk full), the error propagates up and could interrupt the run completion flow.. Wrap file operations in try/except and log warnings rather than failing. Summary writing should be non-blocking like other output capture.", "status": "open", "priority": 3, "created_at": "2026-01-20T18:08:50.581273Z", "updated_at": "2026-01-20T18:08:50.581273Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
{"id": "ralph-dyjo23", "title": "Planner: Add iteration history visibility", "description": "Planner currently only sees last iteration's feedback. Should see summary of ALL previous iterations to recognize patterns like 'same test has failed 3 times with similar errors.' This enables the Planner to say 'stop trying fixes, investigate root cause first.' Implementation: Pass iteration history (number, intent, outcome, executor summary) to Planner prompt.", "status": "closed", "priority": 2, "created_at": "2026-01-18T16:03:27.564996Z", "updated_at": "2026-01-19T15:15:35.315472Z", "closed_at": "2026-01-19T15:15:35.315472Z", "dependencies": [{"depends_on_id": "ralph-1c9p4g", "type": "parent"}], "comments": [{"content": "## Code Analysis\n\n**Files to modify:**\n- `src/ralph2/runner.py` - Build iteration history before calling planner\n- `src/ralph2/agents/planner.py` - Add iteration_history parameter and update prompt\n\n**Current state:**\n- Planner only receives last iteration's feedback via `last_executor_summary`, `last_verifier_assessment`, `last_specialist_feedback` (runner.py:820-828)\n- No visibility into patterns across multiple iterations\n\n**Implementation steps:**\n\n1. In `runner.py`, add helper method to build iteration history:\n```python\ndef _build_iteration_history(self, run_id: str, current_iteration: int) -> list[dict]:\n    \"\"\"Build summary of previous iterations for pattern recognition.\"\"\"\n    iterations = self.db.list_iterations(run_id)\n    history = []\n    for it in iterations:\n        if it.number < current_iteration:\n            history.append({\n                \"number\": it.number,\n                \"intent\": it.intent,\n                \"outcome\": it.outcome,\n                # Get executor summary from agent outputs\n            })\n    return history\n```\n\n2. In `run_planner()` signature (planner.py:202), add parameter:\n```python\niteration_history: Optional[list[dict]] = None,\n```\n\n3. In planner prompt building (planner.py:229-316), add iteration history section:\n```python\nif iteration_history:\n    prompt_parts.append(\"# Iteration History\")\n    prompt_parts.append(\"\")\n    for h in iteration_history:\n        prompt_parts.append(f\"## Iteration {h['number']}\")\n        prompt_parts.append(f\"Intent: {h['intent']}\")\n        prompt_parts.append(f\"Outcome: {h['outcome']}\")\n        prompt_parts.append(\"\")\n```\n\n4. In `PLANNER_SYSTEM_PROMPT`, add guidance:\n```\n## Pattern Recognition\n\nReview iteration history to identify recurring patterns:\n- Same test failing multiple iterations \u2192 investigate root cause before more fixes\n- Same criterion stuck as unverifiable \u2192 may need different approach\n- Repeated \"Blocked\" from executors \u2192 investigate blocker systematically\n```\n\n**Test:** Run ralph2 for 3+ iterations and verify Planner prompt includes history.", "source": "engineer", "created_at": "2026-01-19T15:09:07.922298Z"}]}
{"id": "ralph-fjsmx4", "title": "Write tests for state layer", "description": "Create comprehensive tests for the Soda state layer in tests/soda/state/:\n\n## Test Files to Create\n1. test_models.py - Test Run, Iteration, AgentOutput, HumanInput to_dict() methods\n2. test_db.py - Test SodaDB CRUD operations for all models\n3. test_project.py - Test project ID creation, directory creation, memory read/write, gitignore handling\n\n## Spec Criteria to Verify\n- Project management (4 criteria)\n- Database operations (5 criteria)  \n- Memory management (4 criteria)\n- Human input (3 criteria)\n\nReference ralph2 tests: tests/ralph2/test_state_db.py, tests/ralph2/test_project.py", "status": "open", "priority": 2, "created_at": "2026-01-20T20:30:14.652219Z", "updated_at": "2026-01-20T20:30:14.652219Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-fs2dsc", "title": "Create soda package scaffolding", "description": "Create the basic directory structure and __init__.py files for the soda package. This MUST run alone first before any other work.\n\n## Files to create:\n- src/soda/__init__.py\n- src/soda/types.py (basic Pydantic models: AgentConfig, StructuredOutput)\n- src/soda/agents/__init__.py\n- src/soda/outputs/__init__.py\n- tests/soda/__init__.py\n- tests/soda/test_scaffolding.py (verify imports work)\n\n## Verification:\n1. All directories exist\n2. All __init__.py files exist  \n3. `from soda import types` works\n4. `from soda.agents import *` works\n5. `from soda.outputs import *` works\n6. Basic test passes\n\n## CRITICAL:\n- Verify files exist with `find src/soda -name '*.py'`\n- Run `git status` to confirm changes", "status": "closed", "priority": 0, "created_at": "2026-01-20T18:29:10.937581Z", "updated_at": "2026-01-20T18:35:58.841467Z", "closed_at": "2026-01-20T18:35:58.841467Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on soda package scaffolding. Will create directory structure and basic files.", "source": "executor", "created_at": "2026-01-20T18:30:24.250561Z"}]}
{"id": "ralph-g3lqx5", "title": "src/soda/agents/narrow.py:84-86: Lambda passed to retry handler captures mutable parameters by reference, potentially causing subtle bugs in concurrent scenarios.. If multiple invoke() calls are made concurrently and parameters change, the wrong values could be captured. While not currently a problem with typical usage patterns, this is a subtle correctness issue.. Use functools.partial or capture parameters explicitly in the lambda to ensure correct closure semantics: `partial(self._call_agent, prompt=prompt, tools=tools, model=model)`", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/narrow.py:84-86: Lambda passed to retry handler captures mutable parameters by reference, potentially causing subtle bugs in concurrent scenarios.. If multiple invoke() calls are made concurrently and parameters change, the wrong values could be captured. While not currently a problem with typical usage patterns, this is a subtle correctness issue.. Use functools.partial or capture parameters explicitly in the lambda to ensure correct closure semantics: `partial(self._call_agent, prompt=prompt, tools=tools, model=model)`", "status": "open", "priority": 2, "created_at": "2026-01-20T18:48:03.416182Z", "updated_at": "2026-01-20T18:48:03.416182Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
{"id": "ralph-gqohqn", "title": "src/ralph2/state/db.py:363-378: Iteration conversion logic repeated in list_iterations() and get_latest_iteration(). Similar to the _row_to_run() refactoring that was done for Run objects, Iteration row-to-object conversion is duplicated in list_iterations() and get_latest_iteration() methods.. Extract a _row_to_iteration() helper method similar to _row_to_run() to DRY up the code and ensure consistent parsing.", "description": "Feedback from code_reviewer:\n\nsrc/ralph2/state/db.py:363-378: Iteration conversion logic repeated in list_iterations() and get_latest_iteration(). Similar to the _row_to_run() refactoring that was done for Run objects, Iteration row-to-object conversion is duplicated in list_iterations() and get_latest_iteration() methods.. Extract a _row_to_iteration() helper method similar to _row_to_run() to DRY up the code and ensure consistent parsing.", "status": "open", "priority": 3, "created_at": "2026-01-20T17:53:26.945066Z", "updated_at": "2026-01-20T17:53:26.945066Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-roo932", "type": "parent"}], "comments": []}
{"id": "ralph-i5rcqp", "title": "Capture agent step patterns for meta-analysis", "description": "Enhance logging to capture structured data about what agents do when they succeed, enabling identification of meta-patterns that could inform future architecture decisions.\n\n## Context\nCurrent 3-agent structure (Planner/Executor/Verifier) works, but we want to understand:\n- What steps do agents consistently take when runs converge successfully?\n- Are there repeated sequences/patterns across successful runs?\n- What's the right granularity for future iterations of Ralph?\n\n## The insight\nRalph's principle (fresh context, focused task, loop until convergence) could potentially apply at finer granularity than 3 agents. But we need data to know where the natural boundaries are.\n\n## What to capture\n1. **Step sequences** - What each agent actually did, in order\n2. **Outcomes** - Did iteration make progress? Did run converge? How many iterations?\n3. **Correlation** - Which patterns appear in successful vs unsuccessful runs\n\n## Potential approaches\n- Add structured `steps_taken` field to agent outputs with defined vocabulary\n- Improve existing JSONL logging to be more analyzable\n- Build tooling to query patterns across runs\n\n## Goal\nCollect enough data to answer: \"Here's everything agents do consistently when we get a good result.\"", "status": "open", "priority": 2, "created_at": "2026-01-19T15:03:27.547254Z", "updated_at": "2026-01-19T15:03:27.547254Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-jvgsxa", "title": "Implement Soda Trace integration", "description": "Create Trace CLI integration in src/soda/state/trace.py:\n\n## Spec Criteria\n- WHEN reading work state, THEN open tasks under milestone root returned\n- WHEN reading work state, THEN blocked tasks identified separately\n- WHEN reading work state, THEN recent comments on tasks included\n- WHEN creating a task, THEN created in Trace with title, description, optional parent\n- WHEN closing a task, THEN marked closed in Trace\n- WHEN posting a comment, THEN appears on specified task\n\n## TraceClient Class Methods\n- get_open_tasks(root_id) -> List[Task] - Parse trc ready output\n- get_blocked_tasks(root_id) -> List[Task] - Identify blocked tasks\n- get_task_comments(task_id) -> List[Comment] - Recent comments\n- create_task(title, description, parent=None) -> str (task_id)\n- close_task(task_id) -> None\n- post_comment(task_id, content) -> None\n\n## Implementation\n- Use subprocess to call trc CLI\n- Parse trc output formats\n- Handle trc errors gracefully\n\n## Tests\n- Create tests/soda/state/test_trace.py\n- Mock subprocess calls to trc\n- Test parsing of trc output formats", "status": "closed", "priority": 2, "created_at": "2026-01-20T20:16:33.674860Z", "updated_at": "2026-01-20T20:33:31.328243Z", "closed_at": "2026-01-20T20:33:31.328243Z", "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": [{"content": "Starting work on Trace integration. Will create TraceClient class with methods for reading work state, creating/closing tasks, and posting comments.", "source": "executor", "created_at": "2026-01-20T20:30:54.529478Z"}, {"content": "Implementation complete. Created TraceClient class with all required methods:\n- get_open_tasks(root_id) - parses trc ready output\n- get_blocked_tasks(root_id) - identifies tasks with 'blocked by' markers\n- get_task_comments(task_id) - parses trc show comments section\n- create_task(title, description, parent) - calls trc create\n- close_task(task_id, message) - calls trc close\n- post_comment(task_id, content, source) - calls trc comment\n\nAlso created Task and Comment dataclasses, TraceError exception, and comprehensive tests (21 tests, all passing). All 157 soda tests pass.", "source": "executor", "created_at": "2026-01-20T20:33:18.937656Z"}]}
{"id": "ralph-k6jug5", "title": "src/soda/agents/walked.py:59,60,61,62: Multiple private instance attributes use Python underscore convention but are directly accessed in tests, creating coupling.. Tests directly access `_messages`, `_started`, `_system_prompt`, `_ended` which couples tests to internal implementation. If implementation changes, tests break even if behavior is correct.. Consider adding public read-only properties for state inspection (e.g., `@property def messages` returning a copy), or refactor tests to only verify observable behavior via public methods.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/walked.py:59,60,61,62: Multiple private instance attributes use Python underscore convention but are directly accessed in tests, creating coupling.. Tests directly access `_messages`, `_started`, `_system_prompt`, `_ended` which couples tests to internal implementation. If implementation changes, tests break even if behavior is correct.. Consider adding public read-only properties for state inspection (e.g., `@property def messages` returning a copy), or refactor tests to only verify observable behavior via public methods.", "status": "open", "priority": 3, "created_at": "2026-01-20T18:48:03.523396Z", "updated_at": "2026-01-20T18:48:03.523396Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-krho34", "title": "src/soda/agents/narrow.py:153-156, src/soda/agents/walked.py:200-203, src/soda/outputs/capture.py:81-83: Silent exception swallowing in multiple locations with bare `except Exception: pass` blocks. No logging or error tracking when capture fails.. Debugging will be difficult when output capture silently fails. While non-blocking capture is correct behavior, completely swallowing errors hides potential issues during development.. Add optional logging (e.g., `logging.debug('Output capture failed: %s', e)`) inside the exception handler to aid debugging while maintaining non-blocking behavior.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/narrow.py:153-156, src/soda/agents/walked.py:200-203, src/soda/outputs/capture.py:81-83: Silent exception swallowing in multiple locations with bare `except Exception: pass` blocks. No logging or error tracking when capture fails.. Debugging will be difficult when output capture silently fails. While non-blocking capture is correct behavior, completely swallowing errors hides potential issues during development.. Add optional logging (e.g., `logging.debug('Output capture failed: %s', e)`) inside the exception handler to aid debugging while maintaining non-blocking behavior.", "status": "open", "priority": 3, "created_at": "2026-01-20T18:41:36.658679Z", "updated_at": "2026-01-20T18:41:36.658679Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-qmp15f", "title": "Add comprehensive tests for all agent patterns", "description": "Create test suite covering all agent patterns and infrastructure.\n\n## Test categories\n1. Output capture tests\n   - Capture creates JSONL file\n   - Includes timestamp, agent_type, prompt_summary\n   - Non-blocking on failure\n\n2. Error handling tests\n   - Transient errors trigger retries\n   - Fatal errors halt immediately\n   - Exponential backoff timing\n   - Max retries respected\n\n3. Structured output tests\n   - Valid output returns typed model\n   - Invalid output raises detailed error\n   - Various schema types (simple, nested, optional fields)\n\n4. Narrow agent tests\n   - Returns structured output\n   - Tool restriction works\n   - Conversation captured\n\n5. Walked agent tests\n   - Context persists across sends\n   - Each response captured\n   - Full transcript on end\n\n6. Bookended agent tests\n   - Setup executes first\n   - Work has setup context\n   - Wrap-up has full context\n   - All captured to JSONL\n\n## Technical\n- Use pytest\n- Mock Claude Agent SDK for unit tests\n- Consider integration tests with real API (marked slow)", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:26.262460Z", "updated_at": "2026-01-20T18:01:34.532633Z", "closed_at": "2026-01-20T18:01:34.532633Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": []}
{"id": "ralph-qmuqrr", "title": "src/soda/agents/walked.py:146-170: WalkedAgent._invoke_agent() raises NotImplementedError instead of making actual Claude API calls. The method is a placeholder stub.. WalkedAgent cannot be used in production - only works with mocks in tests. This means walked conversations with the Claude SDK are not functional.. Implement actual Claude SDK integration similar to NarrowAgent._call_agent(). Should use the walked conversation pattern with message history passed to the SDK.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/walked.py:146-170: WalkedAgent._invoke_agent() raises NotImplementedError instead of making actual Claude API calls. The method is a placeholder stub.. WalkedAgent cannot be used in production - only works with mocks in tests. This means walked conversations with the Claude SDK are not functional.. Implement actual Claude SDK integration similar to NarrowAgent._call_agent(). Should use the walked conversation pattern with message history passed to the SDK.", "status": "open", "priority": 1, "created_at": "2026-01-20T18:41:36.498452Z", "updated_at": "2026-01-20T18:41:36.498452Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-ye7sen", "type": "parent"}], "comments": []}
{"id": "ralph-roo932", "title": "Refactoring", "description": "Remaining refactoring work from completed milestone", "status": "open", "priority": 2, "created_at": "2026-01-20T20:03:59.505790Z", "updated_at": "2026-01-20T20:03:59.505790Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-shnc5g", "title": "Implement Soda SQLite database operations", "description": "Create SQLite database operations in src/soda/state/db.py:\n\n## SodaDB Class Methods\n### Schema\n- _init_schema() - Create runs, iterations, agent_outputs, human_inputs tables\n\n### Run Operations\n- create_run(run) -> Run\n- get_run(run_id) -> Optional[Run]\n- update_run_status(run_id, status, ended_at)\n- get_latest_run() -> Optional[Run]\n\n### Iteration Operations\n- create_iteration(iteration) -> Iteration\n- update_iteration(iteration_id, outcome, ended_at)\n- list_iterations(run_id) -> List[Iteration] (ordered by number)\n- get_latest_iteration(run_id) -> Optional[Iteration]\n\n### AgentOutput Operations\n- create_agent_output(output) -> AgentOutput\n- get_agent_outputs(iteration_id) -> List[AgentOutput]\n\n### HumanInput Operations\n- create_human_input(input) -> HumanInput\n- get_unconsumed_inputs(run_id) -> List[HumanInput]\n- mark_input_consumed(input_id, consumed_at)\n\n### Transaction Support\n- transaction() context manager\n- close() method\n\n## Tests\n- Create tests/soda/state/test_db.py\n- Test all CRUD operations\n- Test iteration ordering\n- Test human input consumed logic\n\nReference: src/ralph2/state/db.py", "status": "closed", "priority": 2, "created_at": "2026-01-20T20:16:19.495130Z", "updated_at": "2026-01-20T20:30:02.578761Z", "closed_at": "2026-01-20T20:30:02.578761Z", "dependencies": [{"depends_on_id": "ralph-1dbbg8", "type": "parent"}], "comments": []}
{"id": "ralph-usxwlr", "title": "Verifier: Narrow scope to spec + test adequacy", "description": "Verifier's job is narrowly: (1) Is spec satisfied? (2) Are tests adequate to prove it? Verifier should NOT do root cause analysis on failures. Should NOT research why tests break. CAN say 'these tests are not good enough to have confidence spec is satisfied.' Focus: spec criteria + test quality + thumbs up/down. Remove efficiency notes from Verifier output - that's Executor's job.", "status": "closed", "priority": 2, "created_at": "2026-01-18T16:03:42.388358Z", "updated_at": "2026-01-19T15:10:32.825802Z", "closed_at": "2026-01-19T15:10:32.825802Z", "dependencies": [{"depends_on_id": "ralph-1c9p4g", "type": "parent"}], "comments": [{"content": "## Code Analysis\n\n**File to modify:**\n- `src/ralph2/agents/verifier.py` - Review and potentially remove efficiency notes\n\n**Current state:**\n- Verifier is already assessor-only (good) - see lines 15-20: \"You are an ASSESSOR, not a decision-maker\"\n- Verifier correctly does NOT decide CONTINUE/DONE/STUCK (lines 74-78)\n- BUT Verifier still has efficiency_notes section (lines 82-96) and outputs them\n\n**Issue description says:** \"Remove efficiency notes from Verifier output - that's Executor's job\"\n\n**Decision point:** This is debatable. Current efficiency notes are verification-specific:\n- \"Run `uv run pytest -v` to check all test criteria at once\"\n- \"CLI criteria can be verified with `--help` flags\"\n\nThese ARE useful for future Verifiers. But the issue says Executor owns efficiency notes.\n\n**If we proceed with removal:**\n\n1. Remove efficiency notes section from `VERIFIER_SYSTEM_PROMPT` (lines 82-96)\n\n2. Remove `efficiency_notes` field from `VerifierResult` model in `models.py` (line 120-123)\n\n3. Update `run_verifier()` to not include efficiency_notes in assessment output\n\n**Alternative (if we keep Verifier efficiency notes):**\n- Close this issue as \"won't fix\" with rationale\n- Verifier efficiency notes are about verification shortcuts, distinct from Executor efficiency notes about implementation shortcuts\n\n**Recommendation:** Ask product owner whether Verifier efficiency notes should be kept. They serve a different purpose than Executor notes.\n\n**What's definitely correct (already done):**\n- Verifier is assessor-only \u2713\n- Verifier does not decide CONTINUE/DONE/STUCK \u2713\n- Verifier does not recommend next steps \u2713", "source": "engineer", "created_at": "2026-01-19T15:09:11.925950Z"}, {"content": "## Decision: Keep Verifier efficiency notes\n\nEfficiency notes stay in Verifier. The purpose is to capture learnings from different perspectives:\n- Executor: implementation shortcuts (\"config is in settings.py\")\n- Verifier: verification shortcuts (\"run pytest -v to check all criteria\")\n\nBoth feed into project memory and help future iterations.\n\n## Revised Scope\n\nThe core requirement (Verifier is assessor-only) is **already implemented**:\n- \u2713 Verifier does NOT decide CONTINUE/DONE/STUCK (that's Planner's job)\n- \u2713 Verifier does NOT recommend next steps\n- \u2713 Verifier ONLY reports spec satisfaction status\n\n**No code changes needed.** This issue can be closed.\n\nVerify by reading `src/ralph2/agents/verifier.py` lines 15-20 and 74-78.", "source": "engineer", "created_at": "2026-01-19T15:10:28.261643Z"}]}
{"id": "ralph-vwwbxx", "title": "Implement narrow agent pattern", "description": "Create the narrow agent pattern - single prompt, structured output, optional tool restriction.\n\n## Requirements\n- Invoke with prompt and expected output schema\n- Return structured output matching schema\n- Support tool allowlist (agent only has access to listed tools)\n- Capture full conversation to JSONL file on completion\n\n## Interface\n```python\nclass NarrowAgent:\n    def invoke(\n        self, \n        prompt: str, \n        output_schema: Type[BaseModel],\n        tools: Optional[List[str]] = None\n    ) -> T:\n        \"\"\"Single invocation, returns structured output.\"\"\"\n```\n\n## Dependencies\n- Output capture module\n- Structured output validation\n- Error handling with retry\n\n## Verification\n- Returns Pydantic model matching output_schema\n- When tools specified, only those tools are available\n- Conversation captured to JSONL with timestamp, agent type, prompt summary", "status": "closed", "priority": 2, "created_at": "2026-01-20T17:48:15.267590Z", "updated_at": "2026-01-20T18:05:29.942795Z", "closed_at": "2026-01-20T18:05:29.942795Z", "dependencies": [{"depends_on_id": "ralph-1tbdk4", "type": "parent"}], "comments": [{"content": "Starting work on narrow agent pattern implementation. Will review existing soda infrastructure first.", "source": "executor", "created_at": "2026-01-20T18:01:56.224374Z"}, {"content": "Reviewed existing infrastructure: types.py, errors.py, validation.py, outputs/capture.py. Now writing tests first for NarrowAgent following TDD approach.", "source": "executor", "created_at": "2026-01-20T18:02:29.290356Z"}, {"content": "Implementation complete:\n- Created NarrowAgent class in src/soda/agents/narrow.py\n- Added async retry handler to errors.py (execute_with_retry_async)\n- 21 tests written and all passing\n- Full test suite (119 tests) passes\n- Changes committed to main branch\n\nImplementation details:\n- NarrowAgent.invoke() takes prompt, output_schema, optional tools, optional model\n- Uses existing StructuredOutputValidator for schema validation\n- Uses existing OutputCapture for JSONL conversation capture\n- Integrates with RetryHandler for error handling (transient vs fatal)\n- _call_agent method can be mocked for testing (Claude SDK call)", "source": "executor", "created_at": "2026-01-20T18:05:27.055486Z"}]}
{"id": "ralph-wryan1", "title": "Bug Fixes", "description": "Remaining bug fixes work from completed milestone", "status": "open", "priority": 2, "created_at": "2026-01-20T20:03:59.075611Z", "updated_at": "2026-01-20T20:03:59.075611Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-xpc5ay", "title": "Add memory 50KB warning to write_memory()", "description": "The spec requires: 'WHEN memory exceeds 50KB, THEN a warning is logged'. The write_memory() function in src/soda/project.py needs to check content size and log a warning when exceeding 50KB. Use Python's logging module. This is a small change to project.py.", "status": "open", "priority": 2, "created_at": "2026-01-20T20:30:13.604916Z", "updated_at": "2026-01-20T20:30:13.604916Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-13h2rf", "type": "parent"}], "comments": []}
{"id": "ralph-ye7sen", "title": "Features", "description": "Remaining features work from completed milestone", "status": "open", "priority": 2, "created_at": "2026-01-20T20:03:58.322398Z", "updated_at": "2026-01-20T20:03:58.322398Z", "closed_at": null, "dependencies": [], "comments": []}
{"id": "ralph-yyq7rt", "title": "src/soda/agents/bookended.py:77-125: BookendedAgent.run() does not use RetryHandler for _invoke_agent calls, unlike NarrowAgent which wraps agent calls with retry logic.. Transient errors during bookended agent invocations will not be automatically retried, unlike NarrowAgent. The agent has a _retry_handler attribute but doesn't use it, causing inconsistent error handling between agent patterns.. Wrap _send_prompt() or _invoke_agent() calls with self._retry_handler.execute_with_retry() similar to how NarrowAgent.invoke() does, or document why retry logic is intentionally omitted for conversational patterns.", "description": "Feedback from code_reviewer:\n\nsrc/soda/agents/bookended.py:77-125: BookendedAgent.run() does not use RetryHandler for _invoke_agent calls, unlike NarrowAgent which wraps agent calls with retry logic.. Transient errors during bookended agent invocations will not be automatically retried, unlike NarrowAgent. The agent has a _retry_handler attribute but doesn't use it, causing inconsistent error handling between agent patterns.. Wrap _send_prompt() or _invoke_agent() calls with self._retry_handler.execute_with_retry() similar to how NarrowAgent.invoke() does, or document why retry logic is intentionally omitted for conversational patterns.", "status": "open", "priority": 3, "created_at": "2026-01-20T20:01:56.852783Z", "updated_at": "2026-01-20T20:01:56.852783Z", "closed_at": null, "dependencies": [{"depends_on_id": "ralph-wryan1", "type": "parent"}], "comments": []}
